"use strict";
// import { SagaIterator } from 'redux-saga';
// import { call, put } from 'redux-saga/effects';
// import { ActionType } from 'typesafe-actions';
Object.defineProperty(exports, "__esModule", { value: true });
exports.LOG_PREFIX = void 0;
// import { state, UnacknowledgedMessage } from '@instore/middleware/messenger/state';
// import { allowPairedMessageQueue, constructPairedMessageDetails } from '@instore/middleware/messenger/utils';
// import * as messengerActions from '@instore/redux/messenger/actions';
// import { MessageDetails, SendOptions } from '@instore/redux/messenger/types';
// import { WebSocketCommonAction } from '@instore/utils/enums';
// import { log } from '@instore/utils/log';
exports.LOG_PREFIX = 'Communication::Send::paired';
// /*
//  * Saga: Supports sending to the paired device
//  */
// export const processPairedMessage = function* (action: ActionType<typeof messengerActions.sendPaired>) {
//     const MESSAGE_DETAILS: MessageDetails = yield call(
//         constructPairedMessageDetails,
//         action.payload.data,
//         action.payload.action
//     );
//     if (!MESSAGE_DETAILS.destination) {
//         console.info(`${LOG_PREFIX}::processPairedMessage`, 'Not sending message because destination is not set.');
//         console.info(`${LOG_PREFIX}::processPairedMessage`, MESSAGE_DETAILS);
//         return;
//     }
//     const ALLOW_PAIRED_MESSAGE_QUEUE: boolean =
//         (yield call(allowPairedMessageQueue)) && !action.payload.skipAcknowledgment;
//     const unacknowledgedMessage: UnacknowledgedMessage = {
//         confirmation: action.payload.confirmation,
//         currentEvaluationCount: 0,
//         messageDetails: MESSAGE_DETAILS,
//         totalEvaluationCount: 0,
//         uuid: null
//     };
//     // We check to see if the message queue is empty and if so then the paired message can go out immediately.
//     // If the message queue is not empty the message will get queued until the current message is acknowledged
//     // and then it will be sent.
//     if (state.pairedMessageQueue.size === 0 || !ALLOW_PAIRED_MESSAGE_QUEUE) {
//         unacknowledgedMessage.uuid = yield call(sendPairedMessage, MESSAGE_DETAILS, {
//             skipAcknowledgment: action.payload.skipAcknowledgment,
//             uuid: null
//         });
//     }
//     if (ALLOW_PAIRED_MESSAGE_QUEUE) {
//         state.pairedMessageQueue.add(unacknowledgedMessage);
//     } else {
//         // If we are not waiting on an acknowledgment but we have a confirmation action
//         // the confirmation should go out immediately after sending the message.
//         if (unacknowledgedMessage.confirmation) {
//             yield put(unacknowledgedMessage.confirmation);
//             if (!unacknowledgedMessage.uuid) {
//                 console.warn(
//                     `${LOG_PREFIX}::processPairedMessage`,
//                     `Failed to send ${action.payload.action} message but still dispatched confirmation.`
//                 );
//             }
//         }
//     }
// };
// export const sendPairedMessage = function* (
//     messageDetails: MessageDetails,
//     options: SendOptions
// ): SagaIterator<string | null> {
//     const UUID: string | null = yield call(state.messenger.sendPaired, messageDetails, options);
//     if (!UUID) {
//         console.info(`${LOG_PREFIX}::sendPairedMessage`, `Failed to send message`);
//         console.info(`${LOG_PREFIX}::sendPairedMessage`, messageDetails);
//     }
//     return UUID;
// };
// export const sendSubscriberAuthenticated = function* () {
//     const MESSAGE_DATA: object = {};
//     const MESSAGE_DETAILS: MessageDetails = yield call(
//         constructPairedMessageDetails,
//         MESSAGE_DATA,
//         WebSocketCommonAction.SUBSCRIBER_AUTHENTICATED
//     );
//     if (MESSAGE_DETAILS.destination) {
//         yield call(sendPairedMessage, MESSAGE_DETAILS, {
//             skipAcknowledgment: true,
//             uuid: null
//         });
//     }
// };
