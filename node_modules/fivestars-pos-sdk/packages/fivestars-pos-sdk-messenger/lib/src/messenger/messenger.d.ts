/// <reference types="node" />
import { EventEmitter } from 'events';
import { WebSocketTransport, WebRtcTransport, UdpTransport } from './transports';
import { MessageAcknowledgment, MessageDetails, MessageGeneral, PairedDevice, SendOptions, SentMessagesPerTransport, TransportStatistics, TransportType, ILoyaltyCredentials, TransportPairedQueueThresholds } from '@fivestars-pos-sdk/types';
import { BestTransportOrder } from './bestTransportOrder';
export declare const LOG_PREFIX = "Messenger";
export declare class Messenger extends EventEmitter {
    udpTransport: UdpTransport;
    webSocketTransport: WebSocketTransport;
    webRtcTransport: WebRtcTransport;
    private loyaltyCredentials;
    private lastSendTransportType;
    private receivedMessages;
    private sentMessages;
    private messageToTransports;
    private statsWindowStart;
    private transportsMap;
    /**
     * The order the transports are tried when sending a message.  This can be set by
     * the messenger_transports feature flag. If a transport is ommited from the
     * feature flag, it will not be used.
     *
     * After initially setting the order we update it by analyzing the ping / pong
     * messages to see which transports are "best".
     */
    private transportOrder;
    private bestTransportOrder;
    constructor(udpTransport: UdpTransport, webSocketTransport: WebSocketTransport, webRtcTransport: WebRtcTransport);
    start: (loyaltyCredentials: ILoyaltyCredentials) => Promise<void>;
    setDefaultTransportOrder(transportTypes: TransportType[]): void;
    private shouldReplaceTransportOrder;
    private setTransportOrder;
    /**
     * Send data object using prioritized list of transports
     *
     * @param messageDetails The content to be sent
     * @param options Whether to skip aknowledgments and create a new uuid
     * @returns A promise that resolves to the UUID of the message sent or null if failed
     */
    sendPaired(messageDetails: MessageDetails, options: SendOptions): Promise<string | null>;
    /**
 * Only send message through websocket server (for now)
 *
 * @param messageDetails The content to be sent
 * @param options Whether to skip aknowledgments and create a new uuid
 * @returns A promise that resolves to the UUID of the message sent or null if failed
 */
    sendBroadcast(messageDetails: MessageDetails): Promise<string | null>;
    private trackSentMessage;
    private getLastUsedTransport;
    /**
 * Called when acknowledgments are not coming in, initiates a reconnect on the current transport.
 *
 * @param uuid The identifier for the sent message that was stuck, prompting the reconnect
 * @returns void
 */
    reconnect(uuid?: string): void;
    getPairedQueueThresholds(): TransportPairedQueueThresholds;
    /**
     * Acknowledgment Message Received callback
     * - update statistics for the sent message
     * - send acknowledgemnt action through eventManager
     *
     * @param message
     */
    messageAcknowledgment(message: MessageAcknowledgment, acknowledgedByTransportType: TransportType): void;
    private trackAcknowledgment;
    /**
 * Generic Message received callback
 * - pipe message through eventManager
 * - if message is a paired message, send an Acknowledgment
 *
 * @param message
 */
    messageGeneral(message: MessageGeneral): void;
    getStatsWindowStart(): number;
    getSentMessages(): SentMessagesPerTransport;
    /**
     * Prune sent messages, and set the time of the next window to start now
     */
    resetStats(endTime: number): void;
    getTransportStatistics(endTime: number): TransportStatistics;
    applyBestTransportOrder(startTime: number, endTime: number, transportStatistcs: TransportStatistics): void;
    getBestTransportOrder(): BestTransportOrder | null;
    getSource(): string | null;
    isReadyPaired(): boolean;
    touchReadyTransports(): Promise<void>;
    setPairedDevice(pairedDevice: PairedDevice | null): void;
    onWebRtcMsg: (message: any) => void;
    onWebSocketMsg: (message: any) => void;
    onUdpMsg: (message: any) => void;
}
