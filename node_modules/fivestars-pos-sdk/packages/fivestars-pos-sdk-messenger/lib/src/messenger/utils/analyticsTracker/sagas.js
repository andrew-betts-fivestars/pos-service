"use strict";
// import * as moment from 'moment';
// import { Channel, SagaIterator } from 'redux-saga';
// import { call, delay, put, race, select, spawn, take } from 'redux-saga/effects';
// import * as tdJsSdk from 'td-js-sdk';
// import { CONFIG } from '@app/config';
// import { device } from '@instore/hardware';
// import * as sessionActions from '@instore/redux/session/actions';
// import * as systemActions from '@instore/redux/system/actions';
// import { getIsIndexedDbEnabled } from '@instore/redux/system/selectors';
// import {
//     AnalyticsEventDatabaseOperation,
//     AnalyticsTrackerEventName,
//     AnalyticsTrackerEventProperty
// } from '@instore/utils/enums';
// import { createEventManager, EventManager } from '@instore/utils/eventManager';
// import { log } from '@instore/utils/log';
// import { SkewAdjustedTime } from '@instore/utils/skewAdjustedTime';
// import { storage } from '@instore/utils/storage';
// import {
//     analyticsEventDatabase,
//     analyticsInProgressEventDatabase,
//     CompletedEvent,
//     InProgressEvent
// } from './analyticsEventDatabase';
// import { analyticsEventStats } from './analyticsEventStats';
// import { _analyticsTrackerState, analyticsTracker } from './analyticsTracker';
// import { AnalyticsEventRetryDetail } from './types';
// const DELAY_EVENT_MS = 100;
// const DELAY_RETRY_MS = 1000;
// const TABLE = CONFIG.TREASURE_DATA.get().TABLE;
// const EVENT_PROPERTIES: Set<string> = new Set(Object.values(AnalyticsTrackerEventProperty));
// export const LOG_PREFIX = 'analyticsTracker::sagas';
// export const processingErrorDetails = {
//     generalErrorCount: 0,
//     generalErrorThreshold: 50,
//     quotaExceededCount: 0,
//     quotaExceededMessage: 'QuotaExceededError',
//     quotaExceededThreshold: 3
// };
// /*
//  * The start function needs to be called in the context of a redux-saga.
//  * It is currently called as part of the appStart watcher.
//  *
//  * Initializes analytics SDK, creates redux-saga channel to consume analytics events and store in database
//  * Also spawns a separate saga to take events from the database, and call the analytics SDK with the event
//  */
// export const start = function* () {
//     if (_analyticsTrackerState.eventManager) {
//         throw new Error('Calling start after the eventManager is initialized is not valid.');
//     }
//     if (!CONFIG.TREASURE_DATA.get().DATABASE) {
//         // If we haven't configured a destination database then we just log to console
//         _analyticsTrackerState.eventManager = yield call(createEventManager, { creator: 'AnalyticsTracker' });
//         return;
//     }
//     _analyticsTrackerState.treasureData = new tdJsSdk({
//         database: CONFIG.TREASURE_DATA.get().DATABASE,
//         startInSignedMode: true,
//         writeKey: CONFIG.TREASURE_DATA.get().APIKEY
//     });
//     /*
//      * TODO: Treasure data supports sending up pageviews and clicks automatically.
//      *       However, we the way our application is structure we send up meaningless
//      *       information.  See if we can get better default information for these native
//      *       treasure data tracking events.
//      *
//      * ex., td_path is always '/' and the class names for clicks are jibberish
//      * https://fivestars.atlassian.net/browse/CPAY-114
//      *
//      * _analyticsTrackerState.treasureData.trackPageview(`${TABLE}_pageview`);
//      * _analyticsTrackerState.treasureData.trackClicks({ tableName: `${TABLE}_click` });
//      */
//     _analyticsTrackerState.eventManager = yield call(createEventManager, {
//         creator: 'AnalyticsTracker',
//         listener: _channelWorker
//     });
//     // The webapp_version refers to the mpay/cpay version,
//     // while app_version is overriden by the host and
//     // refers to host version.
//     analyticsTracker.setCommonEventProperty(
//         AnalyticsTrackerEventProperty.WEBAPP_VERSION,
//         CONFIG.VERSION.APP_VERSION
//     );
//     analyticsTracker.setCommonEventProperty(AnalyticsTrackerEventProperty.VERSION, device.APP_VERSION);
//     analyticsTracker.setCommonEventProperty(AnalyticsTrackerEventProperty.DEVICE_SERIAL_NUMBER, device.HARDWARE_ID);
//     analyticsTracker.setCommonEventProperty(AnalyticsTrackerEventProperty.DEVICE_MODEL, device.DEVICE_TYPE);
//     // close out any lingering events from the previous app instance before
//     // we add any new ones to storage.
//     yield call(closeOutExistingTimedEvents);
//     yield spawn(consumeAnalyticsEventsFromDatabase);
// };
// /**
//  * Only close out and track the timed event from the previous app instance if that
//  * event is included in TIMED_EVENTS_TO_SEND. All other events are discarded.
//  * We want to be intentional about which events we care about sending after an app
//  * stop, and we do not want to send a bunch of incomplete events that could potentially
//  * mess up analytics dashboards and metrics.
//  */
// export const TIMED_EVENTS_TO_SEND: AnalyticsTrackerEventName | string[] = [
//     AnalyticsTrackerEventName.ALERT,
//     AnalyticsTrackerEventName.SESSION_START
// ];
// export const closeOutExistingTimedEvents = function* (): SagaIterator<void> {
//     try {
//         const appStopTime: number | null = yield call(storage.getItem, storage.getKeys().LAST_UPTIME_TICK);
//         const inProgressEvents: InProgressEvent[] | undefined = yield call([
//             analyticsInProgressEventDatabase,
//             analyticsInProgressEventDatabase.getAllInProgressEvents
//         ]);
//         inProgressEvents?.forEach(inProgressEvent => {
//             if (!TIMED_EVENTS_TO_SEND.includes(inProgressEvent.eventName.split(':')[0])) {
//                 return;
//             }
//             try {
//                 const timedEvent = JSON.parse(inProgressEvent.event);
//                 timedEvent.endTime = appStopTime ? moment(appStopTime) : null;
//                 analyticsTracker.addTimedEvent(inProgressEvent.eventName, timedEvent);
//                 analyticsTracker.track(inProgressEvent.eventName);
//             } catch (error) {
//                 // error with JSON.parse is not recoverable, throw this event away and move on
//                 console.info(`${LOG_PREFIX}::closeOutExistingTimedEvents::errorCallingTrackOnEvent`, inProgressEvent);
//                 console.info(`${LOG_PREFIX}::closeOutExistingTimedEvents`, error);
//             }
//         });
//         yield call([analyticsInProgressEventDatabase, analyticsInProgressEventDatabase.deleteAllInProgressEvents]);
//     } catch (error) {
//         yield call(_handleProcessingError, `${LOG_PREFIX}::closeOutExistingTimedEvents`, error);
//     }
// };
// export type CompletedEventToStore = {
//     operationType: AnalyticsEventDatabaseOperation.STORE_COMPLETED_EVENT;
//     eventName: AnalyticsTrackerEventName | string;
//     eventData: any;
// };
// export type InProgressEventToStore = {
//     operationType: AnalyticsEventDatabaseOperation.STORE_IN_PROGRESS_EVENT;
//     eventName: AnalyticsTrackerEventName | string;
//     eventData: any;
// };
// export type AnalyticsTrackerEventToOperateOn = CompletedEventToStore | InProgressEventToStore;
// /**
//  * Saga to work through the Analytics Tracker event manager channel
//  * Stores analytics event in the analyticsEventDatabase
//  */
// export const _channelWorker = function* (eventManager: EventManager) {
//     const CHANNEL = eventManager.channel as Channel<AnalyticsTrackerEventToOperateOn>;
//     for (;;) {
//         const eventToOperateOn: AnalyticsTrackerEventToOperateOn = yield take(CHANNEL);
//         const allowProcessing: boolean = yield select(getIsIndexedDbEnabled);
//         if (!allowProcessing) {
//             continue;
//         }
//         try {
//             switch (eventToOperateOn.operationType) {
//                 case AnalyticsEventDatabaseOperation.STORE_COMPLETED_EVENT:
//                     // [INSTORE-1321] write to log file immediately; even though the analytics event upload is deferred
//                     if (_analyticsTrackerState.loggingEnabled) {
//                         console.info(`analyticsTracker: ${eventToOperateOn.eventName}`, eventToOperateOn.eventData);
//                     }
//                     yield analyticsEventDatabase.storeCompletedEvent(eventToOperateOn.eventData);
//                     yield analyticsInProgressEventDatabase.deleteInProgressEvent(eventToOperateOn.eventName);
//                     break;
//                 case AnalyticsEventDatabaseOperation.STORE_IN_PROGRESS_EVENT:
//                     yield analyticsInProgressEventDatabase.storeInProgressEvent(
//                         eventToOperateOn.eventName,
//                         eventToOperateOn.eventData
//                     );
//                     break;
//             }
//         } catch (error) {
//             console.info(`${LOG_PREFIX}::_channelWorker::operateOnEvent`, eventToOperateOn);
//             yield call(_handleProcessingError, `${LOG_PREFIX}::_channelWorker::operateOnEvent`, error);
//         }
//     }
// };
// /**
//  * Saga controlling the piping of events to the analytics platform
//  * Stops analytics events from being sent while in a transaction
//  */
// export const consumeAnalyticsEventsFromDatabase = function* (): SagaIterator<void> {
//     for (;;) {
//         // dbWorker never completes; using the implicit cancel of the race effect to cancel the task
//         yield race({
//             dbWorker: call(dbWorker),
//             sessionStart: take(sessionActions.sessionStarted)
//         });
//         yield take(sessionActions.sessionFinished);
//     }
// };
// /**
//  * Saga to work through the analyticsEventDatabase
//  * Retries events until they are successfully sent
//  */
// export const dbWorker = function* () {
//     let retryDetail: AnalyticsEventRetryDetail | null = null;
//     newEvent: for (;;) {
//         const allowProcessing = yield select(getIsIndexedDbEnabled);
//         if (!allowProcessing) {
//             return;
//         }
//         try {
//             const EVENT: CompletedEvent | undefined = yield analyticsEventDatabase.getNextEvent();
//             if (!EVENT) {
//                 yield delay(DELAY_RETRY_MS);
//                 continue newEvent;
//             }
//             analyticsEventStats.uniqueAttempts += 1;
//             retryEvent: for (;;) {
//                 const allowProcessing = yield select(getIsIndexedDbEnabled);
//                 if (!allowProcessing) {
//                     return;
//                 }
//                 let eventToProcess: string | object = EVENT.event;
//                 let eventSize = -1;
//                 try {
//                     if (typeof EVENT.event !== 'object') {
//                         try {
//                             eventSize = EVENT.event.length;
//                             eventToProcess = JSON.parse(EVENT.event);
//                         } catch (error) {
//                             // error with JSON.parse is not recoverable, throw this event away and move on
//                             console.info(`${LOG_PREFIX}::dbWorker::JSON.parse`, error);
//                             analyticsEventStats.failedToParse += 1;
//                             yield analyticsEventDatabase.deleteCompletedEvent(EVENT.id!);
//                             continue newEvent;
//                         }
//                     }
//                     analyticsEventStats.totalAttempts += 1;
//                     yield call(_eventHandler, eventToProcess);
//                     try {
//                         // the id is auto incremented, so we should always assume that
//                         // it is defined when we pull data out from the db
//                         yield analyticsEventDatabase.deleteCompletedEvent(EVENT.id!);
//                     } catch (error) {
//                         yield call(_handleProcessingError, `${LOG_PREFIX}::dbWorker::deleteEvent`, error);
//                         // re-throw this error so we can retry the whole thing again
//                         // will result in duplicate events on TD, but that should be
//                         // easy to de-dupe
//                         throw error;
//                     }
//                     if (retryDetail) {
//                         analyticsEventStats.retryDetails.push(retryDetail);
//                         retryDetail = null;
//                     }
//                     yield delay(DELAY_EVENT_MS);
//                     // succesfully sent or otherwise filtered and not sent
//                     // we can continue and grab the next event from the channel
//                     continue newEvent;
//                 } catch {
//                     if (!retryDetail) {
//                         retryDetail = {
//                             eventName: eventToProcess['event'],
//                             retryTimes: [SkewAdjustedTime.now()],
//                             size: eventSize,
//                             startTime: eventToProcess['start_time']
//                         };
//                     } else {
//                         retryDetail.retryTimes.push(SkewAdjustedTime.now());
//                     }
//                     // timeout occurred; retry after some delay
//                     yield delay(DELAY_RETRY_MS);
//                     continue retryEvent;
//                 }
//             }
//         } catch (error) {
//             yield call(_handleProcessingError, `${LOG_PREFIX}::dbWorker::getNextEvent`, error);
//             yield delay(DELAY_RETRY_MS);
//         }
//     }
// };
// /**
//  * Perform the actual tracking call to Analytics platform (treasure data)
//  *
//  * Promise resolves if the event is given successfully, or the event should be dropped
//  * because it does not pass validation
//  *
//  * Promise rejects if the event timed out and is retryable
//  */
// export const _eventHandler = async (event: any): Promise<void> =>
//     new Promise<void>((resolve, reject) => {
//         try {
//             if (!event || !event[AnalyticsTrackerEventProperty.EVENT_NAME]) {
//                 throw new Error('An analyticsTracker event must have an event property.');
//             }
//             _validateEventProperties(event);
//             const SUCCESS = () => {
//                 resolve();
//             };
//             const ERROR = () => {
//                 // The Sentry layer now automatically uploads an event to Treasure Data (via AnalyticsTracker) whenever we send an event to Sentry.
//                 // Therefore we do not want the AnalyticsTracker to generate an event that would be sent to Sentry, inadvertently
//                 // creating an unpredictable loop (potentially infinite).
//                 // The AnalyticsTracker should always use a log level that is less than the Sentry notification threshold.
//                 console.info('analyticsTracker::_eventHandler::timeout', event);
//                 reject(new Error('AnalyticsTracker upload timeout.'));
//             };
//             _analyticsTrackerState.treasureData.trackEvent(TABLE, event, SUCCESS, ERROR);
//         } catch (error) {
//             console.warn('analyticsTracker::_eventHandler', error);
//             // resolve promise, because if we have reached this, then there is no way to resend this event
//             resolve();
//         }
//     });
// export const _validateEventProperties = (event: any) => {
//     // validating event properties in the async handler so we don't pay cost when queueing
//     Object.keys(event).forEach((eventProperty: string) => {
//         if (!EVENT_PROPERTIES.has(eventProperty)) {
//             throw new Error(
//                 `The event property "${eventProperty}" is not supported for an analyticsTracker event.`
//             );
//         }
//     });
// };
// export const _handleProcessingError = function* (logKey: string, error: Error) {
//     if (error.message.includes(processingErrorDetails.quotaExceededMessage)) {
//         processingErrorDetails.quotaExceededCount += 1;
//         if (processingErrorDetails.quotaExceededCount === processingErrorDetails.quotaExceededThreshold) {
//             yield put(systemActions.setIndexedDbOff());
//             console.warn(
//                 `${LOG_PREFIX}::stoppingAnalytics`,
//                 `Hit ${processingErrorDetails.quotaExceededThreshold} quota exceeded errors.`
//             );
//         }
//     } else {
//         processingErrorDetails.generalErrorCount += 1;
//         if (processingErrorDetails.generalErrorCount === processingErrorDetails.generalErrorThreshold) {
//             yield put(systemActions.setIndexedDbOff());
//             console.warn(
//                 `${LOG_PREFIX}::stoppingAnalytics`,
//                 `Hit ${processingErrorDetails.generalErrorThreshold} general errors.`
//             );
//         }
//     }
//     console.warn(logKey, error);
// };
