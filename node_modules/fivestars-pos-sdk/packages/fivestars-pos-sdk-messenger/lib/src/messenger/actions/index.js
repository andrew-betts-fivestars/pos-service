"use strict";
// import { ActionType, createAction } from 'typesafe-actions';
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.initialized = exports.erroneousPairing = exports.messageReceived = exports.webSocket = exports.webRtc = exports.udp = void 0;
// import { Acknowledgment, MessageDetails } from '../types';
// import * as _bluetooth from './transports/bluetooth';
var _udp = __importStar(require("./transports/udp"));
var _webRtc = __importStar(require("./transports/webRtc"));
var _webSocket = __importStar(require("./transports/webSocket"));
/**
 * Export all actions directly, shouldn't ever need to import from anything lower than the /actions level
 */
__exportStar(require("./paired"), exports);
__exportStar(require("./broadcast"), exports);
__exportStar(require("./server"), exports);
// export const bluetooth = _bluetooth;
exports.udp = _udp;
exports.webRtc = _webRtc;
exports.webSocket = _webSocket;
// export type WebSocketActions = ActionType<typeof webSocket>;
// export const messageReceived = createAction(
//     'MESSENGER_MESSAGE_RECEIVED',
//     resolve => (messageDetails: MessageDetails) => resolve({ messageDetails, ...LOG_FILTER })
// );
var messageReceived = function (messageDetails) {
    return { action: 'MESSENGER_MESSAGE_RECEIVED', data: messageDetails };
};
exports.messageReceived = messageReceived;
// export const acknowledgement = createAction(
//     'MESSENGER_ACKNOWLEDGEMENT',
//     resolve => (acknowledgement: Acknowledgment) => resolve({ acknowledgement, ...LOG_FILTER })
// );
// export const sessionMismatch = createAction(
//     'MESSENGER_SESSION_MISMATCH',
//     resolve => (thisDeviceSessionId: string | null, pairedDeviceSessionId: string | null) =>
//         resolve({ pairedDeviceSessionId, thisDeviceSessionId })
// );
// export const erroneousPairing = createAction(
//     'MESSENGER_ERRONEOUS_PAIRING',
//     resolve => (thisDeviceApiKey: string, erroneouslyPairedDeviceApiKey: string) =>
//         resolve({ erroneouslyPairedDeviceApiKey, thisDeviceApiKey })
// );
var erroneousPairing = function (thisDeviceApiKey, erroneouslyPairedDeviceApiKey) { return ({
    action: 'MESSENGER_ERRONEOUS_PAIRING',
    data: { erroneouslyPairedDeviceApiKey: erroneouslyPairedDeviceApiKey, thisDeviceApiKey: thisDeviceApiKey }
}); };
exports.erroneousPairing = erroneousPairing;
// export const clearPairedMessageQueue = createAction('MESSENGER_CLEAR_PAIRED_MESSAGE_QUEUE');
// export const pairedQueueIssueReconnect = createAction('MESSENGER_PAIRED_QUEUE_ISSUE_RECONNECT');
// export const receivedStartFinished = createAction('MESSENGER_RECEIVED_START_FINISHED');
// export const resetStats = createAction('MESSENGER_RESET_STATS', resolve => (endTime: number) =>
//     resolve({ endTime })
// );
// export const switchTransport = createAction(
//     'MESSENGER_SWITCH_TRANSPORT',
//     resolve => (obj: { from: TransportType; to: TransportType }) => resolve({ ...obj })
// );
// /**
//  * Dispatched from outage tracking
//  */
// export const messengerUp = createAction('MESSENGER_MESSENGER_UP');
// export const messengerDown = createAction('MESSENGER_MESSENGER_DOWN');
// /**
//  * Action used to kick-start outage tracking check when a paired message fails to send off of the queue.
//  * Transports are likely all exhausted at this point, however the outage tracking only periodically (30 seconds)
//  * checks the state of messenger's ability to send messages
//  */
// export const pairedQueueSendFailed = createAction('MESSENGER_PAIRED_QUEUE_SEND_FAILED');
// export const initialized = createAction('MESSENGER_INITIALIZED');
var initialized = function () { return ({ action: 'MESSENGER_INITIALIZED' }); };
exports.initialized = initialized;
