"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports._getReliability = exports._getDurationScore = exports._getTransportFactors = exports._isRuleMedian = exports._isRuleReliability = exports._isRuleSticky = exports._setOrder = exports._sortTransportFactors = exports._getFactorAggregation = exports._setTransportFactorFlags = exports._initializeFactors = exports.getBestTransportOrder = exports.BestTransportRule = void 0;
var config_1 = require("@fivestars-pos-sdk/config");
var formatter_1 = require("./utils/formatter");
var BestTransportRule;
(function (BestTransportRule) {
    BestTransportRule["MEDIAN"] = "MEDIAN";
    BestTransportRule["NONE"] = "NONE";
    BestTransportRule["ONE"] = "ONE";
    BestTransportRule["RELIABILITY"] = "RELIABILITY";
    BestTransportRule["SCORE"] = "SCORE";
    BestTransportRule["STICKY"] = "STICKY";
})(BestTransportRule = exports.BestTransportRule || (exports.BestTransportRule = {}));
var getBestTransportOrder = function (startTimeInMs, endTimeInMs, transportStatistcs, previousTransportOrder, previousBestTransportFactors) {
    var bestTransportOrder = {
        allTransportFactors: [],
        order: [],
        periodDuration: endTimeInMs - startTimeInMs,
        rule: BestTransportRule.NONE,
        switch: false
    };
    exports._initializeFactors(bestTransportOrder, transportStatistcs, previousTransportOrder);
    exports._setTransportFactorFlags(bestTransportOrder.allTransportFactors);
    exports._sortTransportFactors(bestTransportOrder.allTransportFactors, previousBestTransportFactors);
    exports._setOrder(bestTransportOrder, previousBestTransportFactors);
    return bestTransportOrder;
};
exports.getBestTransportOrder = getBestTransportOrder;
var _initializeFactors = function (bestTransportOrder, transportStatistcs, previousTransportOrder) {
    // for (const transportType of previousTransportOrder) {
    //     const PING_PONG_DURATION_STATS: PingPongDurationStats | undefined =
    //         transportStatistcs[transportType]['pingPongDurationStats'];
    //     if (!PING_PONG_DURATION_STATS) {
    //         bestTransportOrder.allTransportFactors.push({
    //             actualCount: 0,
    //             durationScore: null,
    //             expectedCount: 0,
    //             isAcceptableMedian: false,
    //             isReliable: false,
    //             medianDuration: null,
    //             reliability: null,
    //             transportType
    //         });
    //         continue;
    //     }
    //     const TRANSPORT_FACTORS: TransportFactors = _getTransportFactors(
    //         transportType,
    //         bestTransportOrder.periodDuration,
    //         PING_PONG_DURATION_STATS
    //     );
    //     bestTransportOrder.allTransportFactors.push(TRANSPORT_FACTORS);
    // }
    // AB todo: need to implement above lines
};
exports._initializeFactors = _initializeFactors;
var _setTransportFactorFlags = function (allTransportFactors) {
    var factorAggregation = exports._getFactorAggregation(allTransportFactors);
    allTransportFactors.forEach(function (transportFactors) {
        if (transportFactors.reliability &&
            factorAggregation.maxReliability - transportFactors.reliability <
                config_1.CONFIG.MESSENGER.BEST_TRANSPORT.RELIABILITY_THRESHOLD) {
            transportFactors.isReliable = true;
        }
        if (transportFactors.medianDuration &&
            (transportFactors.medianDuration < config_1.CONFIG.MESSENGER.BEST_TRANSPORT.MEDIAN_CEILING_IN_MS ||
                transportFactors.medianDuration / factorAggregation.minMedianDuration <
                    config_1.CONFIG.MESSENGER.BEST_TRANSPORT.MEDIAN_PCT_DIFF_THRESHOLD)) {
            transportFactors.isAcceptableMedian = true;
        }
    });
};
exports._setTransportFactorFlags = _setTransportFactorFlags;
var _getFactorAggregation = function (allTransportFactors) {
    var maxReliability = 0.0;
    var minMedianDuration = Number.MAX_SAFE_INTEGER;
    allTransportFactors.forEach(function (transportFactors) {
        if (transportFactors.reliability && transportFactors.reliability > maxReliability) {
            maxReliability = transportFactors.reliability;
        }
        if (transportFactors.medianDuration && transportFactors.medianDuration < minMedianDuration) {
            minMedianDuration = transportFactors.medianDuration;
        }
    });
    return {
        maxReliability: maxReliability,
        minMedianDuration: minMedianDuration
    };
};
exports._getFactorAggregation = _getFactorAggregation;
var _sortTransportFactors = function (allTransportFactors, previousBestTransportFactors) {
    allTransportFactors.sort(function (currentTransportFactors, previousTransportFactors) {
        if (currentTransportFactors.isReliable && !previousTransportFactors.isReliable) {
            return -1;
        }
        if (!currentTransportFactors.isReliable && previousTransportFactors.isReliable) {
            return 1;
        }
        if (currentTransportFactors.isAcceptableMedian && !previousTransportFactors.isAcceptableMedian) {
            return -1;
        }
        if (!currentTransportFactors.isAcceptableMedian && previousTransportFactors.isAcceptableMedian) {
            return 1;
        }
        if (currentTransportFactors.durationScore && !previousTransportFactors.durationScore) {
            return -1;
        }
        if (!currentTransportFactors.durationScore && previousTransportFactors.durationScore) {
            return 1;
        }
        if (currentTransportFactors.durationScore && previousTransportFactors.durationScore) {
            if (currentTransportFactors.durationScore.score > previousTransportFactors.durationScore.score) {
                return -1;
            }
            if (currentTransportFactors.durationScore.score < previousTransportFactors.durationScore.score) {
                return 1;
            }
        }
        // A bunch of tie breakers
        if (currentTransportFactors.transportType === (previousBestTransportFactors === null || previousBestTransportFactors === void 0 ? void 0 : previousBestTransportFactors.transportType)) {
            return -1;
        }
        if (previousTransportFactors.transportType === (previousBestTransportFactors === null || previousBestTransportFactors === void 0 ? void 0 : previousBestTransportFactors.transportType)) {
            return 1;
        }
        if (currentTransportFactors.medianDuration && previousTransportFactors.medianDuration) {
            return currentTransportFactors.medianDuration - previousTransportFactors.medianDuration;
        }
        return 0;
    });
};
exports._sortTransportFactors = _sortTransportFactors;
var _setOrder = function (bestTransportOrder, previousBestTransportFactors) {
    // Initialize the order with any transports that do not have pings
    bestTransportOrder.order = bestTransportOrder.allTransportFactors
        .filter(function (transportFactors) { return !transportFactors.actualCount; })
        .map(function (transportFactors) { return transportFactors.transportType; });
    var POSSIBLE_BEST_TRANSPORT_FACTORS = bestTransportOrder.allTransportFactors.filter(function (transportFactors) {
        return transportFactors.actualCount;
    });
    // If there are no transports with pings then we exit immediately
    if (!POSSIBLE_BEST_TRANSPORT_FACTORS.length) {
        bestTransportOrder.switch = previousBestTransportFactors ? true : false;
        return;
    }
    var BEST_TRANSPORT_FACTOR = POSSIBLE_BEST_TRANSPORT_FACTORS[0];
    var POSSIBLE_SWITCH = previousBestTransportFactors &&
        BEST_TRANSPORT_FACTOR.transportType !== previousBestTransportFactors.transportType
        ? true
        : false;
    // If there is only one transport with pings then that is the best
    if (POSSIBLE_BEST_TRANSPORT_FACTORS.length === 1) {
        bestTransportOrder.order.unshift(BEST_TRANSPORT_FACTOR.transportType);
        bestTransportOrder.rule = BestTransportRule.ONE;
        bestTransportOrder.switch = POSSIBLE_SWITCH;
        return;
    }
    var PENULTIMATE_TRANSPORT_FACTOR = bestTransportOrder.allTransportFactors[1];
    // If the previous transport and penultimate are close in score and the best is close to the penultimate
    // then we keep the previous transport to avoid unnecessary flapping of the best transport
    if (previousBestTransportFactors) {
        if (exports._isRuleSticky(BEST_TRANSPORT_FACTOR, PENULTIMATE_TRANSPORT_FACTOR, previousBestTransportFactors)) {
            POSSIBLE_BEST_TRANSPORT_FACTORS.reverse().forEach(function (transportFactors) {
                if (transportFactors.transportType !== previousBestTransportFactors.transportType) {
                    bestTransportOrder.order.unshift(transportFactors.transportType);
                }
            });
            bestTransportOrder.order.unshift(previousBestTransportFactors.transportType);
            bestTransportOrder.rule = BestTransportRule.STICKY;
            bestTransportOrder.switch = false;
            return;
        }
    }
    // If we get here then the sort order defines the order for the transports
    POSSIBLE_BEST_TRANSPORT_FACTORS.reverse().forEach(function (transportFactors) {
        bestTransportOrder.order.unshift(transportFactors.transportType);
    });
    // Here we determine the appropriate rule to apply to the best transport
    if (exports._isRuleReliability(BEST_TRANSPORT_FACTOR, PENULTIMATE_TRANSPORT_FACTOR)) {
        bestTransportOrder.rule = BestTransportRule.RELIABILITY;
    }
    else if (exports._isRuleMedian(BEST_TRANSPORT_FACTOR, PENULTIMATE_TRANSPORT_FACTOR)) {
        bestTransportOrder.rule = BestTransportRule.MEDIAN;
    }
    else {
        bestTransportOrder.rule = BestTransportRule.SCORE;
    }
    bestTransportOrder.switch = POSSIBLE_SWITCH;
};
exports._setOrder = _setOrder;
/*
 * When the previous transport and the penultimate transport scores are close and the best transport
 * and the penultimate are also very close then we prefer the penultimate so that we avoid transport
 * switching for small changes in score.
 *
 * @param {TransportFactors} bestTransportFactor - The current selection for best transport
 * @param {TransportFactors} penultimateTransportFactor - The second selection for best transport
 * @param {TransportFactors} previousBestTransportFactors - The previous selection for best transport
 */
var _isRuleSticky = function (bestTransportFactor, penultimateTransportFactor, previousBestTransportFactors) {
    return penultimateTransportFactor.transportType === previousBestTransportFactors.transportType &&
        bestTransportFactor.durationScore &&
        penultimateTransportFactor.durationScore &&
        previousBestTransportFactors.durationScore &&
        bestTransportFactor.durationScore.score - penultimateTransportFactor.durationScore.score <
            config_1.CONFIG.MESSENGER.BEST_TRANSPORT.STICKY_THRESHOLD &&
        previousBestTransportFactors.durationScore.score - penultimateTransportFactor.durationScore.score <
            config_1.CONFIG.MESSENGER.BEST_TRANSPORT.STICKY_THRESHOLD
        ? true
        : false;
};
exports._isRuleSticky = _isRuleSticky;
/*
 * When the best transport is reliable and the penultimate transport is not reliable
 * then the rule applied was reliability.
 *
 * @param {TransportFactors} bestTransportFactor - The current selection for best transport
 * @param {TransportFactors} penultimateTransportFactor - The second selection for best transport
 */
var _isRuleReliability = function (bestTransportFactor, penultimateTransportFactor) {
    return bestTransportFactor.isReliable && !penultimateTransportFactor.isReliable;
};
exports._isRuleReliability = _isRuleReliability;
/*
 * When the best transport has an acceptable median and penultimate transport does not have an
 * acceptable median duration then the rule applied was median.  Also, if the scores for the
 * best transport and the penultimate transport are the same and the best transport has a lower
 * median duration than the penultimate we also applied the median rule.
 *
 * @param {TransportFactors} bestTransportFactor - The current selection for best transport
 * @param {TransportFactors} penultimateTransportFactor - The second selection for best transport
 */
var _isRuleMedian = function (bestTransportFactor, penultimateTransportFactor) {
    var _a, _b;
    return ((bestTransportFactor.isAcceptableMedian && !penultimateTransportFactor.isAcceptableMedian) ||
        (((_a = bestTransportFactor.durationScore) === null || _a === void 0 ? void 0 : _a.score) === ((_b = penultimateTransportFactor.durationScore) === null || _b === void 0 ? void 0 : _b.score) &&
            bestTransportFactor.medianDuration &&
            penultimateTransportFactor.medianDuration &&
            bestTransportFactor.medianDuration < penultimateTransportFactor.medianDuration
            ? true
            : false));
};
exports._isRuleMedian = _isRuleMedian;
var _getTransportFactors = function (transportType, periodDurationInMs, pingPongDurationStats) {
    // Since the ping timer and the heartbeat timer are not
    // synchronized, subtract one from expected to apply a
    // fudge factor when the last ping has received a pong.
    // Also, make sure expected is never zero as it is used
    // as a denominator.
    var EXPECTED_COUNT = Math.max(Math.round(periodDurationInMs / config_1.CONFIG.MESSENGER.PING_FREQUENCY_IN_MS) - 1, 1);
    return {
        actualCount: pingPongDurationStats.countAcknowledged,
        durationScore: exports._getDurationScore(pingPongDurationStats),
        expectedCount: EXPECTED_COUNT,
        isAcceptableMedian: false,
        isReliable: false,
        medianDuration: pingPongDurationStats.medianDuration,
        reliability: exports._getReliability(EXPECTED_COUNT, pingPongDurationStats),
        transportType: transportType
    };
};
exports._getTransportFactors = _getTransportFactors;
var _getDurationScore = function (pingPongDurationStats) {
    if (!pingPongDurationStats.countAcknowledged) {
        return null;
    }
    var POSITIVE_DURATION_FACTOR = (pingPongDurationStats.totalCountUnder250 / pingPongDurationStats.countAcknowledged) *
        config_1.CONFIG.MESSENGER.BEST_TRANSPORT.DURATION_SCORE.POSITIVE_WEIGHT;
    var AVG_VS_BAD_DURATION_FACTOR = pingPongDurationStats.totalCount250Plus > 2
        ? (1 - pingPongDurationStats.totalCount1000Plus / pingPongDurationStats.totalCount250Plus) *
            config_1.CONFIG.MESSENGER.BEST_TRANSPORT.DURATION_SCORE.AVG_VS_BAD_WEIGHT
        : config_1.CONFIG.MESSENGER.BEST_TRANSPORT.DURATION_SCORE.AVG_VS_BAD_WEIGHT;
    var SCORE = POSITIVE_DURATION_FACTOR + AVG_VS_BAD_DURATION_FACTOR;
    return {
        avgVsBadFactor: formatter_1.Formatter.formatToFixedPrecision(AVG_VS_BAD_DURATION_FACTOR, 2),
        positiveFactor: formatter_1.Formatter.formatToFixedPrecision(POSITIVE_DURATION_FACTOR, 2),
        score: formatter_1.Formatter.formatToFixedPrecision(SCORE, 2),
        totalCount1000Plus: pingPongDurationStats.totalCount1000Plus,
        totalCount250Plus: pingPongDurationStats.totalCount250Plus,
        totalCountUnder250: pingPongDurationStats.totalCountUnder250
    };
};
exports._getDurationScore = _getDurationScore;
var _getReliability = function (expectedCount, pingPongDurationStats) {
    if (!pingPongDurationStats.countAcknowledged) {
        return null;
    }
    // Max out reliability at 100%.  Note there is a little
    // ambiguity here because the count acknowledged and
    // the expected count are not completely synchronized.
    return formatter_1.Formatter.formatToFixedPrecision(Math.min(pingPongDurationStats.countAcknowledged / expectedCount, 1.0), 2);
};
exports._getReliability = _getReliability;
