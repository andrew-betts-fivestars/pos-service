"use strict";
// import { SagaIterator } from 'redux-saga';
// import { call, put } from 'redux-saga/effects';
// import { ActionType, getType } from 'typesafe-actions';
// import { CONFIG } from '@app/config';
// import { MessageHandler as AppMessageHandler } from '@app/middleware/messenger/receive/messageHandler';
// import { device } from '@instore/hardware';
// import * as apiActions from '@instore/redux/api/actions';
// import * as messengerActions from '@instore/redux/messenger/actions';
// import * as pairingActions from '@instore/redux/pairing/actions';
// import * as systemActions from '@instore/redux/system/actions';
// import { DeviceType, Product, ShutdownSource } from '@instore/utils/enums';
// export const MessageHandler = {
//     *process(action: ActionType<typeof messengerActions.messageReceived>): SagaIterator<null> {
//         if (action.type !== getType(messengerActions.messageReceived)) {
//             return null;
//         }
//         const MESSAGE_DATA: any = action.payload.messageDetails.messageData;
//         switch (action.payload.messageDetails.messageType) {
//             case 'ws.web_socket_version':
//                 yield put(systemActions.pairedDeviceMessengerVersion(MESSAGE_DATA.version));
//                 break;
//             case 'ws.start_finished':
//                 yield put(messengerActions.receivedStartFinished());
//                 break;
//             case 'ws.device_mapping':
//                 yield put(
//                     pairingActions.deviceMapping(
//                         MESSAGE_DATA.apiKey,
//                         MESSAGE_DATA.apiSecret,
//                         MESSAGE_DATA.bluetoothMacAddress,
//                         MESSAGE_DATA.udpPort,
//                         MESSAGE_DATA.deviceDescription,
//                         MESSAGE_DATA.hardwareId
//                     )
//                 );
//                 break;
//             case 'ws.rtc_answer':
//                 yield put(messengerActions.webRtc.rtcAnswer(MESSAGE_DATA.signalData));
//                 break;
//             case 'ws.rtc_offer':
//                 yield put(messengerActions.webRtc.rtcOffer(MESSAGE_DATA.signalData));
//                 break;
//             case 'ws.erroneous_pairing':
//                 yield put(
//                     pairingActions.erroneousPairing(
//                         MESSAGE_DATA.erroneousDeviceApiKey,
//                         MESSAGE_DATA.pairedDeviceApiKey
//                     )
//                 );
//                 break;
//             case 'ws.proxied_api_request_v2':
//                 yield put(apiActions.apiRequestForPairedDevice(MESSAGE_DATA.proxiedApiRequest));
//                 break;
//             case 'ws.proxied_api_response_v2':
//                 yield put(apiActions.apiResponseFromPairedDevice(MESSAGE_DATA.proxiedApiResponse));
//                 break;
//             case 'ws.internet_status':
//                 yield put(systemActions.setPairedDeviceInternetStatus(MESSAGE_DATA.internetStatus));
//                 break;
//             /**
//              * Mission Control messages
//              */
//             case 'ws.force_unpair':
//                 yield put(pairingActions.unpair());
//                 break;
//             case 'ws.reboot':
//                 if (device.DEVICE_TYPE === DeviceType.PAX_A920) {
//                     // TEMP - Remove in [CPAY-1376] once we have better updating
//                     // wait 10 minutes to re-start the app to allow a chance for the pax app update to occur
//                     const DELAY_BEFORE_STARTUP_MS = 600000;
//                     yield put(systemActions.restartBegin(ShutdownSource.MISSION_CONTROL, DELAY_BEFORE_STARTUP_MS));
//                     break;
//                 }
//                 yield put(systemActions.restartBegin(ShutdownSource.MISSION_CONTROL));
//                 break;
//             case 'ws.fs_log_refresh':
//                 yield put(systemActions.requestUploadLogs());
//                 break;
//         }
//         // do not allow recursive call to process, if @app and @instore are the same
//         // this only occurs when running INSTORE as a stand-alone
//         if (CONFIG.PRODUCT !== Product.INSTORE) {
//             yield call(AppMessageHandler.process, action);
//         }
//         return null;
//     }
// };
