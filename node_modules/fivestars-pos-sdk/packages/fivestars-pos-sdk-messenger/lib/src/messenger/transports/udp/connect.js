"use strict";
// import { SagaIterator, Task } from 'redux-saga';
// import { call, cancel, delay, fork, race, spawn, take } from 'redux-saga/effects';
// import { CONFIG } from '@app/config';
// import { state } from '@instore/middleware/messenger/state';
// import * as messengerActions from '@instore/redux/messenger/actions';
// import * as pairingActions from '@instore/redux/pairing/actions';
// import { Product } from '@instore/utils/enums';
// import { log } from '@instore/utils/log';
// import { storage } from '@instore/utils/storage';
// import { SYNCHRONIZATION_TRIGGERS } from '@instore/utils/synchronizationTriggers';
// import { UdpSocket } from './udpSocket';
// import { UdpTransport } from './udpTransport';
// const {
//     // remove authenticationSuccessful (websocket authentication) from triggers
//     authenticationSuccessful: _,
//     // remove startFinished; this was being hit after mpay itself was restarting, re-triggering the offer for no reason
//     startFinished: __,
//     ...UDP_SYNCHRONIZATION_TRIGGERS
// } = SYNCHRONIZATION_TRIGGERS;
// export const LOG_PREFIX = 'udp::connect';
// export function* setupUdpConnection() {
//     // check if this environment is set up to work with UDP
//     // if not, then exit this saga and never try again
//     if (!allowUdp()) {
//         return;
//     }
//     yield spawn(_broadcastApiKey);
//     // When the paired device available flag is false the udp connection
//     // cannot be used for paired communication.  We validate there is a
//     // paired device through the ping / pong.
//     yield call(state.messenger.udpTransport.setPairedDeviceAvailable, false);
//     for (;;) {
//         yield call(_openSocket);
//         const RUN_PING_PONG_TASK: Task = yield fork(_runPingPong);
//         // wait for a reason to restart the transport
//         const RESULT = yield race({
//             reconnectRequest: take(messengerActions.udp.reconnectRequest),
//             sync: race({ ...UDP_SYNCHRONIZATION_TRIGGERS }),
//             unpair: take(pairingActions.unpair)
//         });
//         console.info(`${LOG_PREFIX}::setupUdpConnection`, `Stop using UDP because: ${JSON.stringify(RESULT)}`);
//         yield cancel(RUN_PING_PONG_TASK);
//         // Stop the transport from being used for paired messages
//         yield call(state.messenger.udpTransport.setPairedDeviceAvailable, false);
//         if (RESULT.unpair) {
//             // Wait for pairing to be restored and then we need
//             // to get a pong from the new paired device
//             yield take(pairingActions.pair);
//         } else if (RESULT.reconnectRequest) {
//             // Stop and then call _openSocket which will re-bind the socket
//             yield call(state.messenger.udpTransport.stop);
//         }
//     }
// }
// function allowUdp(): boolean {
//     const INSTORE_WINDOW: InstoreWindow = window;
//     if (CONFIG.PRODUCT === Product.WINPAY) {
//         if (!INSTORE_WINDOW.cef_udpMessenger) {
//             console.info(`${LOG_PREFIX}::_allowUdp`, 'CEF UDP Messenger is not set.');
//             return false;
//         }
//     } else if (![Product.CPAY, Product.MREG].includes(CONFIG.PRODUCT) || !('Plugins' in INSTORE_WINDOW)) {
//         console.info(`${LOG_PREFIX}::_allowUdp`, 'UDP is not an available option.');
//         return false;
//     }
//     return true;
// }
// /**
//  * Gets the order of port numbers to try
//  * If a previous port was being used, prioritize re-using that port number
//  */
// export function* _getPortsOrder(): SagaIterator<number[]> {
//     const PORT_RANGE = 10;
//     const DEFAULT_PORTS: number[] = [...Array(PORT_RANGE)].map((_i, index) => UdpSocket.DEFAULT_PORT + index);
//     const CACHED_UDP_PORT: number | null = yield call(storage.getItem, storage.getKeys().UDP_PORT);
//     return CACHED_UDP_PORT ? [CACHED_UDP_PORT, ...DEFAULT_PORTS.filter(i => i !== CACHED_UDP_PORT)] : DEFAULT_PORTS;
// }
// /**
//  * Continually try to open a socket, using pre-determined port numbers
//  */
// export function* _openSocket(): SagaIterator<void> {
//     if (yield call(state.messenger.udpTransport.getIsOpen)) {
//         console.info(`${LOG_PREFIX}::_openSocket`, 'socket already open');
//         return;
//     }
//     const OUTER_LOOP_DELAY_MS: number = 1000 * 60 * 5; // 5 minutes
//     const DELAY_MS = 5000;
//     const WAIT_FOR_STOP_MS = 1000;
//     const PORTS: number[] = yield call(_getPortsOrder);
//     console.info(`${LOG_PREFIX}::_openSocket`, 'attempting to open UDP socket');
//     // Keep trying until we are connected.  If we never connect the only negative
//     // consequence is that we have noise in the logs.
//     for (;;) {
//         for (const port of PORTS) {
//             yield call(state.messenger.udpTransport.stop);
//             yield delay(WAIT_FOR_STOP_MS);
//             yield call(state.messenger.udpTransport.openSocket, port);
//             yield delay(DELAY_MS);
//             // exit looping once openSocket works
//             if (yield call(state.messenger.udpTransport.getIsOpen)) {
//                 console.info(`${LOG_PREFIX}::_openSocket`, `Successful: bound to port ${port}`);
//                 return;
//             }
//         }
//         yield delay(OUTER_LOOP_DELAY_MS);
//     }
// }
// export function* _runPingPong(): SagaIterator<void> {
//     yield take(messengerActions.udp.receivedPairedDeviceBroadcast);
//     for (;;) {
//         const PAIRED_DEVICE_CONFIRMED = yield call(_testForPairedDevice);
//         if (PAIRED_DEVICE_CONFIRMED) {
//             yield call(state.messenger.udpTransport.setPairedDeviceAvailable, true);
//             yield delay(CONFIG.MESSENGER.PING_FREQUENCY_IN_MS);
//         } else {
//             yield call(state.messenger.udpTransport.setPairedDeviceAvailable, false);
//             // If we didn't receive the pong then wait and then resend the ping
//             yield take(messengerActions.udp.receivedPairedDeviceBroadcast);
//         }
//     }
// }
// /**
//  * Test paired device is available by sending a uni-cast udp-test-ping and wait for a udp-test-pong to come back
//  * Waits on a timeout to receive the pong
//  *
//  * @returns boolean indicating if there was a success
//  */
// export function* _testForPairedDevice(): SagaIterator<boolean> {
//     const TIMEOUT_MS = 5000;
//     const RETRY_COUNT = 3;
//     let count = 0;
//     for (;;) {
//         if (count >= RETRY_COUNT) {
//             console.info(`${LOG_PREFIX}::pairedDeviceTest`, 'giving up waiting for pong from paired device');
//             return false;
//         }
//         try {
//             yield call(state.messenger.udpTransport.sendPing);
//         } catch (error) {
//             console.info(`${LOG_PREFIX}::pairedDeviceTest failed to send paired device test ping`, error);
//             yield call(state.messenger.udpTransport.triggerReconnect);
//             return false;
//         }
//         const RESULT = yield race({
//             pong: take(messengerActions.udp.pongReceived),
//             timeout: delay(TIMEOUT_MS)
//         });
//         if (RESULT.pong) {
//             return true;
//         }
//         count += 1;
//     }
// }
// /**
//  * Continuously send api key as a broadcast message
//  *
//  * Note: This is currently useful for both:
//  * - setting up the paired devices
//  * - collecting stats and giving data for outage tracking
//  *
//  * However; eventually we may not want to ALWAYS be broadcasting.
//  * In that case, we could start a task after opening the socket and cancel the task
//  * once we have established the paired device is available for udp
//  */
// export function* _broadcastApiKey() {
//     const WAIT_ON_OPEN_IN_MS = 5000;
//     const SEND_FREQUENCY_IN_MS = 30000;
//     const UDP_TRANSPORT: UdpTransport = state.messenger.udpTransport;
//     let countWaitForOpen = 0;
//     for (;;) {
//         while (!UDP_TRANSPORT.getIsOpen()) {
//             countWaitForOpen += 1;
//             yield delay(WAIT_ON_OPEN_IN_MS * countWaitForOpen);
//         }
//         countWaitForOpen = 0;
//         try {
//             yield call(UDP_TRANSPORT.sendApiKeyBroadcast);
//             yield call(UDP_TRANSPORT.incrementBroadcastSent);
//         } catch (error) {
//             console.info('updBroadcast::trackUdpBroadcast', error);
//             yield call(UDP_TRANSPORT.incrementBroadcastSentFailed);
//         }
//         yield delay(SEND_FREQUENCY_IN_MS);
//     }
// }
