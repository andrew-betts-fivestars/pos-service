"use strict";
// import { SagaIterator } from 'redux-saga';
// import { call, put, race, select, take } from 'redux-saga/effects';
// import simplePeer from 'simple-peer';
// import { getType } from 'typesafe-actions';
// import { state } from '@instore/middleware/messenger/state';
// import { getLoyaltyCredentials } from '@instore/redux/authentication/selectors';
// import * as messengerActions from '@instore/redux/messenger/actions';
// import { RtcOfferAction, SignalDataAction } from '@instore/redux/messenger/actions/transports/webRtc';
// import { log } from '@instore/utils/log';
// export const LOG_PREFIX = 'webRtc::acceptor';
// /**
//  * Saga representing life-cycle of the WebRTC connection life-cycle for the acceptor, i.e. cPay
//  *
//  * acceptor: responsible for responding to a WebRTC offer
//  *
//  * This is significantly simpler than it could be.
//  * Not listening on unpair action or anything of that sort, to stop the connection early.
//  * Only use the second rtcOffer action to decide that we should re-connect
//  */
// export function* acceptor() {
//     const OFFER_ACTION: RtcOfferAction = yield take(getType(messengerActions.webRtc.rtcOffer));
//     let offerSignalData: simplePeer.SignalData = OFFER_ACTION.payload.signalData;
//     for (;;) {
//         // wait for offer to come in, and set remote description
//         // this causes signal data to be generated
//         yield call(state.messenger.webRtcTransport.setRemoteDescription, offerSignalData);
//         // wait for signal data to be generated, and respond with the answer
//         const SIGNAL_DATA_ACTION: SignalDataAction = yield take(getType(messengerActions.webRtc.signalData));
//         yield put(messengerActions.webRtc.sendRtcAnswer(SIGNAL_DATA_ACTION.payload.data));
//         offerSignalData = yield call(_waitForReconnect);
//     }
// }
// type ReconnectRace = { newOffer: RtcOfferAction } | { reconnectRequest: void };
// /**
//  * Wait for another offer to come in.
//  * Stop the current connection and start it again
//  *
//  * @returns signal data of the new offer, to be used to re-connect
//  */
// export function* _waitForReconnect(): SagaIterator<simplePeer.SignalData> {
//     const RECONNECT_RACE: ReconnectRace = yield race({
//         newOffer: take(getType(messengerActions.webRtc.rtcOffer)),
//         reconnectRequest: take(getType(messengerActions.webRtc.reconnectRequest))
//     });
//     console.info(`${LOG_PREFIX}::_waitForReconnect`, `Stop using webrtc: ${JSON.stringify(RECONNECT_RACE)}`);
//     yield call(state.messenger.webRtcTransport.stop);
//     // if a new offer has come in, immediately use that
//     // otherwise we need to explicitly wait for the offer to come in again
//     let offerAction: RtcOfferAction;
//     if ('newOffer' in RECONNECT_RACE) {
//         offerAction = RECONNECT_RACE.newOffer;
//     } else {
//         offerAction = yield take(getType(messengerActions.webRtc.rtcOffer));
//     }
//     const OFFER_SIGNAL_DATA: simplePeer.SignalData = offerAction.payload.signalData;
//     yield call(state.messenger.webRtcTransport.start, yield select(getLoyaltyCredentials));
//     return OFFER_SIGNAL_DATA;
// }
