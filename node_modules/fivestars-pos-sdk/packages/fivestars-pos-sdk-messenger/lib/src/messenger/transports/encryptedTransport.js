"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.EncryptedTransport = void 0;
var crypto_js_1 = require("crypto-js");
var pako_1 = require("pako");
//import { log } from '@instore/utils/log';
// AB todo: implement above log
var transport_1 = require("./transport");
var EncryptedTransport = /** @class */ (function (_super) {
    __extends(EncryptedTransport, _super);
    function EncryptedTransport() {
        var _this = _super.call(this) || this;
        _this.decryptionIgnore = new Set();
        return _this;
    }
    EncryptedTransport.prototype.parse = function (message) {
        try {
            return this.decrypt(message);
        }
        catch (error) {
            if (this.decryptionIgnore.has(message)) {
                // discard this message since we've already seen it, and had trouble decrypting it
                return null;
            }
            console.info(this.transportType + "::parse error decrypting and parsing message", error);
        }
        /**
         * To prevent decryption errors from dominating the logs; store the raw message that had a decryption error
         * and discard messages that come in that match
         */
        this.decryptionIgnore.add(message);
        return null;
    };
    /**
     * Encrypt message using our paired device's api secret
     * @param message
     */
    EncryptedTransport.prototype.encrypt = function (message) {
        // If paired device is not set, use OUR api-secret for encryption.
        // NOTE: This should not happen, as encrypted transports are not
        // enabled to send paired messages unless they are paired.
        var ENCRYPTION_KEY = this.pairedDevice
            ? this.pairedDevice.apiSecret
            : this.loyaltyCredentials.apiSecret;
        var COMPRESSED_JSON_STRING = pako_1.gzip(JSON.stringify(message), { to: 'string' });
        return crypto_js_1.AES.encrypt(COMPRESSED_JSON_STRING, ENCRYPTION_KEY).toString();
    };
    /**
     * Decrypt incoming messages using our api-secret
     * If we are unable to decrypt and parse the message, it should not be trusted
     */
    EncryptedTransport.prototype.decrypt = function (cipherText) {
        var BYTES = crypto_js_1.AES.decrypt(cipherText, this.loyaltyCredentials.apiSecret);
        return JSON.parse(pako_1.ungzip(BYTES.toString(crypto_js_1.enc.Utf8), { to: 'string' }));
    };
    return EncryptedTransport;
}(transport_1.Transport));
exports.EncryptedTransport = EncryptedTransport;
