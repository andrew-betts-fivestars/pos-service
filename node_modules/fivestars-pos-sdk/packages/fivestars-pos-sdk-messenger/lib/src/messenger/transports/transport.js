"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Transport = exports.LOG_PREFIX = void 0;
var events_1 = require("events");
var types_1 = require("@fivestars-pos-sdk/types");
var fivestars_pos_sdk_storage_1 = require("@fivestars-pos-sdk/fivestars-pos-sdk-storage");
var stats_1 = require("../../messenger/stats");
var messengerActions = __importStar(require("../actions"));
// import { DurationStats, getDurationStats, UNACKNOWLEDGED_MARKER } from '@instore/middleware/messenger/stats';
// import { ILoyaltyCredentials } from '@instore/redux/authentication/types';
// import * as messengerActions from '@instore/redux/messenger/actions';
// import { Acknowledgment, Message, MessageAcknowledgment, MessageGeneral } from '@instore/redux/messenger/types';
// import { PairedDevice } from '@instore/redux/pairing/types';
// import { log } from '@instore/utils/log';
var packedApiKey_1 = require("../utils/packedApiKey");
var skewAdjustedTime_1 = require("../utils/skewAdjustedTime");
// import { TransportPairedQueueThresholds, TransportType } from '../types';
exports.LOG_PREFIX = 'Transport';
/**
 * @template MessageExtra -- additional data reported by a transport's onMessageCallback to be forwarded
 *                           along to every hook in the message processing. E.g. IP Address and Port for a UDP message
 */
var Transport = /** @class */ (function (_super) {
    __extends(Transport, _super);
    function Transport() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.pairedDevice = null;
        _this.isOpen = false;
        // passed into start method with the idea it can change
        _this.loyaltyCredentials = { apiKey: '', apiSecret: '', softwareId: '' };
        /**
         * When defining a new transport, these properties should be overloaded
         */
        _this.transportType = types_1.TransportType.WEB_SOCKET; // Defaulting to Websocket, but put the correct type in when subclassing
        _this.reconnectThreshold = -1;
        _this.resendThreshold = -1;
        _this.pingPongEvents = {};
        _this.pingPongStats = {
            pingReceived: 0,
            pingSent: 0,
            pingSentFailed: 0,
            pongReceived: 0,
            pongSent: 0,
            pongSentFailed: 0
        };
        return _this;
    }
    Transport.prototype.start = function (loyaltyCredentials) {
        this.loyaltyCredentials = loyaltyCredentials;
        console.log('Transport::start ', loyaltyCredentials);
        return Promise.resolve();
    };
    Transport.prototype.setPairedDevice = function (pairedDevice) {
        console.log('Transport::setPairedDevice ', pairedDevice);
        this.pairedDevice = pairedDevice;
    };
    /*
     * Send data object via overridden channel
     * @param {MessageGeneral} [message] - The content to be sent
     * @returns {Promise<void>} indicating success or failure to send
     *
     * Note: A promise is necessary because some channels determine if the
     *       send failed asynchronously.
     */
    Transport.prototype.send = function (_message) {
        console.log('Transport::send ', _message);
        return Promise.reject(new Error('The send method must be overridden.'));
    };
    /**
     * Denotes that a transport is open and ready to be used
     */
    Transport.prototype.isReady = function () {
        console.log('Transport::isReady');
        return false;
    };
    Transport.prototype.getPairedQueueThresholds = function () {
        console.log('Transport::getPairedQueueThresholds');
        return {
            reconnect: this.reconnectThreshold,
            resend: this.resendThreshold
        };
    };
    /**
     * An extra option for a transport that may be ready for use, but there is no guarantee yet
     * that the paired device is ready to accept messages on this transport
     *
     * e.g. UDP socket is opened and usable, but we haven't gotten confirmation from the other end
     *
     * By default, just uses isReady
     */
    Transport.prototype.isReadyPaired = function () {
        console.log('Transport::isReadyPaired');
        return this.isReady();
    };
    Transport.prototype.getIsOpen = function () {
        console.log('Transport::getIsOpen');
        return this.isOpen;
    };
    Transport.prototype.onOpenCallback = function (_event) {
        console.log('Transport::onOpenCallback ', _event);
    };
    Transport.prototype.onCloseCallback = function (_event) {
        console.log('Transport::onCloseCallback ', _event);
    };
    Transport.prototype.onErrorCallback = function (event) {
        console.log('Transport::onErrorCallback ', event);
        console.info(exports.LOG_PREFIX + "::onErrorCallback", event);
    };
    Transport.prototype.onMessageCallback = function (message, extra) {
        console.log('Transport::onMessageCallback ', message);
        // If necessary this is overridden in the child class
        var MESSAGE = this.parse(message, extra);
        if (!MESSAGE) {
            console.log('Transport::onMessageCallback !MESSAGE returning');
            return;
        }
        console.info(exports.LOG_PREFIX + "::onMessageCallback::" + this.transportType, MESSAGE);
        // This is a private base class method that is applied
        // to all messages regardless of channel
        if (this.filterInvalidMessage(MESSAGE, extra)) {
            console.log('Transport::onMessageCallback filterInvalidMessage true returning');
            return;
        }
        // If necessary this is overridden in the child class
        if (this.filterMessage(MESSAGE, extra)) {
            console.log('Transport::onMessageCallback filterMessage true returning');
            return;
        }
        if (this.handleTransportSpecificMessage(MESSAGE, extra)) {
            console.log('Transport::onMessageCallback handleTransportSpecificMessage true returning');
            return;
        }
        if (MESSAGE.action === types_1.Acknowledgment) {
            console.log('Transport::onMessageCallback MESSAGE.action === Acknowledgment dispatchAction MESSAGE returning', MESSAGE);
            // AB todo: need to implement this 
            //            state.messenger.messageAcknowledgment(MESSAGE as MessageAcknowledgment, this.transportType);
            this.dispatchAction(MESSAGE);
            return;
        }
        // AB todo: need to implement this 
        console.log('Transport::onMessageCallback dispatchAction MESSAGE', MESSAGE);
        //       state.messenger.messageGeneral(MESSAGE);
        this.dispatchAction(MESSAGE);
    };
    Transport.prototype.parse = function (event, _extra) {
        console.log('Transport::parse ', event);
        return JSON.parse(event);
    };
    /**
     * Makes sure that messages are valid before further processing
     * @param message
     * @returns boolean -- true, if message is invalid
     */
    Transport.prototype.filterInvalidMessage = function (message, _extra) {
        console.log('Transport::filterInvalidMessage ', message);
        if (!message.action) {
            console.log('Transport::filterInvalidMessage !message.action');
            console.warn(exports.LOG_PREFIX + "::filterMessage::" + this.transportType, 'Received a message without an action.');
            return true;
        }
        var THIS_DEVICE_API_KEY = packedApiKey_1.getApiKey(message.destination);
        if (THIS_DEVICE_API_KEY) {
            // If the destination is populated (i.e., it is a paired message)
            // then the embedded apikey must match this device.
            //            if (THIS_DEVICE_API_KEY !== AuthModel.loyaltyCredentials.apiKey) {
            if (THIS_DEVICE_API_KEY !== this.loyaltyCredentials.apiKey) {
                console.log("Transport::filterInvalidMessage THIS_DEVICE_API_KEY=" + THIS_DEVICE_API_KEY + " ", message);
                return true;
            }
            // If it is a paired message and the source does not match the paired device then
            // dispatch the erroneous pairing action which will resolve the issue with the device
            // that erroneously thinks it is paired with this device.
            var PAIRED_DEVICE_API_KEY = packedApiKey_1.getApiKey(message.source);
            if (PAIRED_DEVICE_API_KEY &&
                (!fivestars_pos_sdk_storage_1.PairingModel.pairedDevice || PAIRED_DEVICE_API_KEY !== fivestars_pos_sdk_storage_1.PairingModel.pairedDevice.apiKey)) {
                // AB todo: implement this by emitting message for erroneousPairing
                if (this.pairedDevice) {
                    console.log("Transport::filterInvalidMessage this.pairedDevice = " + this.pairedDevice + " returning true");
                    this.dispatchAction(messengerActions.erroneousPairing(THIS_DEVICE_API_KEY, PAIRED_DEVICE_API_KEY));
                }
                console.log("Transport::filterInvalidMessage THIS_DEVICE_API_KEY = " + THIS_DEVICE_API_KEY + " returning true");
                return true;
            }
        }
        else {
            console.log("Transport::filterInvalidMessage THIS_DEVICE_API_KEY = " + THIS_DEVICE_API_KEY + " returning false");
        }
        return false;
    };
    Transport.prototype.filterMessage = function (_message, _extra) {
        console.log('Transport::filterMessage ', _message);
        return false;
    };
    Transport.prototype.handleTransportSpecificMessage = function (_message, _extra) {
        console.log('Transport::handleTransportSpecificMessage ', _message);
        return false;
    };
    Transport.prototype.trackPingSent = function (message) {
        console.log('Transport::trackPingSent ', message);
        this.pingPongEvents[message.uuid] = {
            pingSentTimeInMs: skewAdjustedTime_1.SkewAdjustedTime.now(),
            pongReceiveTimeInMs: null
        };
        this.pingPongStats.pingSent += 1;
    };
    Transport.prototype.trackPongReceived = function (message) {
        console.log('Transport::trackPongReceived ', message);
        if (message.uuid in this.pingPongEvents) {
            var PING_PONG_EVENT = this.pingPongEvents[message.uuid];
            PING_PONG_EVENT['pongReceiveTimeInMs'] = skewAdjustedTime_1.SkewAdjustedTime.now();
        }
        this.pingPongStats.pongReceived += 1;
    };
    Transport.prototype.getPingPongDurationStats = function (endTime) {
        console.log('Transport::getPingPongDurationStats ', endTime);
        return stats_1.getDurationStats(Object.values(this.pingPongEvents)
            // Events with a sent time that is after the end time
            // will be filtered out so that we do not erroneously
            // catalog them as unacknowledged when in fact we have
            // not given the pong enough time to arrive.  This is
            // an imperfect approach and the "pingSent" metric does
            // not apply this filter but for now it is good enough.
            .filter(function (pingPongEvent) { return pingPongEvent.pingSentTimeInMs <= endTime; })
            // Something likely happened with the clock skew and we want to exclude
            // negative durations as they are not helpful when picking a transport.
            .filter(function (pingPongEvent) {
            return pingPongEvent.pongReceiveTimeInMs === null ||
                pingPongEvent.pongReceiveTimeInMs > pingPongEvent.pingSentTimeInMs;
        })
            .map(function (pingPongEvent) {
            // We use this marker to indicate there was not a response
            // for this message.  The getDurationStats function will
            // filter it out for most metrics.  It will be used for
            // the count of unacknowledged.
            if (!pingPongEvent.pongReceiveTimeInMs) {
                return stats_1.UNACKNOWLEDGED_MARKER;
            }
            return pingPongEvent.pongReceiveTimeInMs - pingPongEvent.pingSentTimeInMs;
        }));
    };
    Transport.prototype.resetStats = function (endTime) {
        var _this = this;
        console.log('Transport::resetStats', endTime);
        Object.entries(this.pingPongEvents).forEach(function (_a) {
            var uuid = _a[0], pingPongEvent = _a[1];
            if (pingPongEvent.pingSentTimeInMs <= endTime) {
                delete _this.pingPongEvents[uuid];
            }
        });
        this.pingPongStats = {
            pingReceived: 0,
            pingSent: 0,
            pingSentFailed: 0,
            pongReceived: 0,
            pongSent: 0,
            pongSentFailed: 0
        };
    };
    Transport.prototype.getStats = function (_endTime) {
        console.log('Transport::getStats', _endTime);
        return {};
    };
    /**
     * Emit Action onto EventManager - which eventually put into a redux-saga channel
     * The actions taken from this channel are dispatched into the rest of redux
     *
     * @param action
     */
    //    protected dispatchAction(action: Record<string, unknown>): void {
    Transport.prototype.dispatchAction = function (action) {
        console.log('Transport::dispatchAction', action);
        console.info(exports.LOG_PREFIX + "::dispatchAction::" + this.transportType, action);
        this.emit('message', action);
        //        state.messenger.eventManager.eventEmitter(action);
    };
    Transport.prototype.triggerReconnect = function () {
        console.log('Transport::triggerReconnect');
    };
    Transport.prototype.touch = function () {
        console.log('Transport::touch');
        return Promise.resolve();
    };
    return Transport;
}(events_1.EventEmitter));
exports.Transport = Transport;
