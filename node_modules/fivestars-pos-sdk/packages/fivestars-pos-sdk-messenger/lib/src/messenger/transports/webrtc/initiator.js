"use strict";
// import { SagaIterator } from 'redux-saga';
// import { call, put, race, select, take } from 'redux-saga/effects';
// import simplePeer from 'simple-peer';
// import { getType } from 'typesafe-actions';
// import { state } from '@instore/middleware/messenger/state';
// import { getLoyaltyCredentials } from '@instore/redux/authentication/selectors';
// import * as messengerActions from '@instore/redux/messenger/actions';
// import { RtcAnswerAction, SignalDataAction } from '@instore/redux/messenger/actions/transports/webRtc';
// import * as pairingActions from '@instore/redux/pairing/actions';
// import { getIsPairingConfigured } from '@instore/redux/pairing/selectors';
// import { analyticsTracker } from '@instore/utils/analyticsTracker';
// import { delay } from '@instore/utils/delay';
// import { AnalyticsTrackerEventName, AnalyticsTrackerEventProperty } from '@instore/utils/enums';
// import { log } from '@instore/utils/log';
// import { SYNCHRONIZATION_TRIGGERS } from '@instore/utils/synchronizationTriggers';
// const WAIT_FOR_ANSWER_TIMEOUT = 30000;
// export const LOG_PREFIX = 'webRtc::initiator';
// /**
//  * Saga representing lifecycle of the WebRTC connection life-cycle for the initiator, i.e. mPay
//  *
//  * initiator: responsible for creating the WebRTC offer, and initiating the entire connection process
//  */
// export function* initiator(): SagaIterator<void> {
//     let offerSignalData: simplePeer.SignalData = yield call(_restartTransport);
//     try {
//         for (;;) {
//             const ANSWER_SIGNAL_DATA: simplePeer.SignalData | null = yield call(
//                 _performOfferWaitForAnswer,
//                 offerSignalData
//             );
//             if (!ANSWER_SIGNAL_DATA) {
//                 offerSignalData = yield call(_restartTransport);
//                 continue;
//             }
//             const READY: boolean = yield call(_setRemoteDescriptionWaitForReady, ANSWER_SIGNAL_DATA);
//             if (!READY) {
//                 console.info(`${LOG_PREFIX}`, 'data channel not ready after setting remote description, restart');
//                 offerSignalData = yield call(_restartTransport);
//                 continue;
//             }
//             // wait until we need to reconnect; we get back the signal data needed to create a new offer
//             const RESULT = yield race(RECONNECT_CONDITIONS);
//             console.info(`${LOG_PREFIX}`, `restarting transport: ${JSON.stringify(RESULT)}`);
//             offerSignalData = yield call(_restartTransport);
//         }
//     } catch (error) {
//         analyticsTracker.track(AnalyticsTrackerEventName.WEB_RTC_INITIATOR_ABORT, {
//             [AnalyticsTrackerEventProperty.ERROR_MESSAGE]: error.message
//         });
//     }
// }
// type WaitForAnswerRace = { answer: RtcAnswerAction } | { reconnect: void } | { timeout: void };
// /**
//  * Sends RTC offer and waits for the answer.
//  * Can timeout or be interrupted by RECONNECT_CONDITIONS
//  *
//  * @param offerSignalData
//  * @returns signal data from the answer, or null if reconnect is necessary
//  */
// export function* _performOfferWaitForAnswer(
//     offerSignalData: simplePeer.SignalData
// ): SagaIterator<simplePeer.SignalData | null> {
//     yield put(messengerActions.webRtc.sendRtcOffer(offerSignalData));
//     const WAIT_FOR_ANSWER: WaitForAnswerRace = yield race({
//         answer: take(getType(messengerActions.webRtc.rtcAnswer)),
//         // restart connection process if standard reconnect triggers hit
//         // OR if timeout is hit
//         reconnect: race(RECONNECT_CONDITIONS),
//         timeout: call(delay, WAIT_FOR_ANSWER_TIMEOUT)
//     });
//     if ('reconnect' in WAIT_FOR_ANSWER) {
//         return null;
//     }
//     if ('timeout' in WAIT_FOR_ANSWER) {
//         console.info(`${LOG_PREFIX}::_performOfferWaitForAnswer`, 'timed out waiting for RTC answer');
//         return null;
//     }
//     return WAIT_FOR_ANSWER.answer.payload.signalData;
// }
// export function* _setRemoteDescriptionWaitForReady(answerSignalData: simplePeer.SignalData): SagaIterator<boolean> {
//     // set remote description; wait for transport to become ready or timeout
//     yield call(state.messenger.webRtcTransport.setRemoteDescription, answerSignalData);
//     const WAIT_FOR_READY = yield race({
//         ready: take(getType(messengerActions.webRtc.ready)),
//         reconnect: race(RECONNECT_CONDITIONS),
//         timeout: call(delay, WAIT_FOR_ANSWER_TIMEOUT)
//     });
//     if ('reconnect' in WAIT_FOR_READY || 'timeout' in WAIT_FOR_READY) {
//         return false;
//     }
//     return true;
// }
// /**
//  * Calls stop on transport; destroying the connection
//  * Calls start on transport; creating a new connection
//  * Then waits on the signal data to be generated again
//  *
//  * @returns next signal data to be used in an offer
//  */
// export function* _restartTransport(): SagaIterator<simplePeer.SignalData> {
//     yield call(state.messenger.webRtcTransport.stop);
//     const ALLOW_RECONNECT: boolean = yield call(state.messenger.webRtcTransport.allowReconnect);
//     if (!ALLOW_RECONNECT) {
//         throw new Error('WebRTC error threshold reached, abandon WebRTC as a transport');
//     }
//     // if unpaired, need to wait for pairing before continuing
//     const IS_PAIRED: boolean = yield select(getIsPairingConfigured);
//     if (!IS_PAIRED) {
//         yield take(getType(pairingActions.pair));
//     }
//     yield call(state.messenger.webRtcTransport.start, yield select(getLoyaltyCredentials));
//     // wait for signal data to be re-generated by WebRtcTransport
//     const SIGNAL_DATA_ACTION: SignalDataAction = yield take(getType(messengerActions.webRtc.signalData));
//     return SIGNAL_DATA_ACTION.payload.data;
// }
// const {
//     // remove authenticationSuccessful (websocket authentication) from triggers
//     authenticationSuccessful: _,
//     // remove startFinished; this was being hit after mpay itself was restarting, re-triggering the offer for no reason
//     startFinished: __,
//     ...INITIATOR_SYNCHRONIZATION_TRIGGERS
// } = SYNCHRONIZATION_TRIGGERS;
// const RECONNECT_CONDITIONS = {
//     reconnectRequest: take(messengerActions.webRtc.reconnectRequest),
//     stopped: take(messengerActions.webRtc.stopped),
//     sync: race({ ...INITIATOR_SYNCHRONIZATION_TRIGGERS }),
//     unpair: take(pairingActions.unpair)
// };
