/// <reference types="node" />
import { EventEmitter } from 'events';
import { ILoyaltyCredentials, Message, MessageGeneral, TransportPairedQueueThresholds, TransportType, PairedDevice } from '@fivestars-pos-sdk/types';
import { DurationStats } from '../../messenger/stats';
export declare const LOG_PREFIX = "Transport";
export declare type PingPongEvent = {
    pingSentTimeInMs: number;
    pongReceiveTimeInMs: number | null;
};
export declare type PingPongEvents = {
    [uuid: string]: PingPongEvent;
};
export declare type PingPongStats = {
    pingSent: number;
    pingSentFailed: number;
    pingReceived: number;
    pongSent: number;
    pongSentFailed: number;
    pongReceived: number;
};
export declare type PingPongDurationStats = DurationStats;
/**
 * @template MessageExtra -- additional data reported by a transport's onMessageCallback to be forwarded
 *                           along to every hook in the message processing. E.g. IP Address and Port for a UDP message
 */
export declare class Transport<MessageExtra = Record<string, unknown>> extends EventEmitter {
    protected pairedDevice: PairedDevice | null;
    isOpen: boolean;
    protected loyaltyCredentials: ILoyaltyCredentials;
    /**
     * When defining a new transport, these properties should be overloaded
     */
    transportType: TransportType;
    protected reconnectThreshold: number;
    protected resendThreshold: number;
    protected pingPongEvents: PingPongEvents;
    protected pingPongStats: PingPongStats;
    start(loyaltyCredentials: ILoyaltyCredentials): Promise<void>;
    setPairedDevice(pairedDevice: PairedDevice | null): void;
    send(_message: MessageGeneral): Promise<void>;
    /**
     * Denotes that a transport is open and ready to be used
     */
    isReady(): boolean;
    getPairedQueueThresholds(): TransportPairedQueueThresholds;
    /**
     * An extra option for a transport that may be ready for use, but there is no guarantee yet
     * that the paired device is ready to accept messages on this transport
     *
     * e.g. UDP socket is opened and usable, but we haven't gotten confirmation from the other end
     *
     * By default, just uses isReady
     */
    isReadyPaired(): boolean;
    getIsOpen(): boolean;
    protected onOpenCallback(_event: any): void;
    protected onCloseCallback(_event: any): void;
    protected onErrorCallback(event: any): void;
    protected onMessageCallback(message: any, extra?: MessageExtra): void;
    protected parse(event: any, _extra?: MessageExtra): Message | null;
    /**
     * Makes sure that messages are valid before further processing
     * @param message
     * @returns boolean -- true, if message is invalid
     */
    private filterInvalidMessage;
    protected filterMessage(_message: Message, _extra?: MessageExtra): boolean;
    protected handleTransportSpecificMessage(_message: Message, _extra?: MessageExtra): boolean;
    protected trackPingSent(message: Message): void;
    protected trackPongReceived(message: Message): void;
    protected getPingPongDurationStats(endTime: number): PingPongDurationStats;
    resetStats(endTime: number): void;
    getStats(_endTime: number): object;
    /**
     * Emit Action onto EventManager - which eventually put into a redux-saga channel
     * The actions taken from this channel are dispatched into the rest of redux
     *
     * @param action
     */
    protected dispatchAction(action: any): void;
    triggerReconnect(): void;
    touch(): Promise<void>;
}
