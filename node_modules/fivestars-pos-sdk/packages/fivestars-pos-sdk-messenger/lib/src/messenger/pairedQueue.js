"use strict";
// import { all, call, delay, fork, put, race, select, take, takeLatest } from 'redux-saga/effects';
// import { ActionType, getType } from 'typesafe-actions';
// import * as alertActions from '@instore/redux/alert/actions';
// import { getIsPairedQueueBackup } from '@instore/redux/alert/selectors';
// import * as healthAggregationActions from '@instore/redux/health/aggregation/actions';
// import * as messengerActions from '@instore/redux/messenger/actions';
// import { Acknowledgment } from '@instore/redux/messenger/types';
// import { analyticsTracker } from '@instore/utils/analyticsTracker';
// import { AnalyticsTrackerEventName, AnalyticsTrackerEventProperty } from '@instore/utils/enums';
// import { WS_DELAY } from '@instore/utils/healthAggregationRules';
// import { log } from '@instore/utils/log';
// import { outageTracker } from '@instore/utils/outageTracker';
// import { sendPairedMessage } from './send/paired';
// import { state, UnacknowledgedMessage } from './state';
// import { PairedQueueFailedMessage, TransportPairedQueueThresholds } from './types';
// import { LOG_PREFIX } from './utils';
// export const watcher = function* () {
//     yield all([
//         takeLatest(getType(messengerActions.clearPairedMessageQueue), clearPairedMessageQueue),
//         fork(pairedQueue)
//     ]);
// };
// export const clearPairedMessageQueue = function* () {
//     state.pairedMessageQueue.clear();
//     yield put(alertActions.clearPairedQueueBackupAlert());
//     return null;
// };
// /**
//  * Saga that handles paired queue processing. Stopping and starting paired queue processing
//  */
// export const pairedQueue = function* () {
//     for (;;) {
//         console.info(`${LOG_PREFIX}::pairedQueue`, 'Starting paired queue processing');
//         yield call(processPairedQueueUntilDown);
//         console.info(
//             `${LOG_PREFIX}::pairedQueue`,
//             'Messenger down. Stopping paired queue processing. Periodically try reconnect, and wait for messenger to come back up'
//         );
//         // when messenger goes down, issue periodic reconnect attempts
//         // this is a last-ditch effort for when things are truly in a horrible situation
//         // ideally, when all transports are down, they should already be attempting to get themselves re-connected independently
//         // this is just extra assurance that while in this state we are guaranteed to at least be trying to make forward progress
//         yield race([call(periodicMessengerReconnect), take(messengerActions.messengerUp)]);
//     }
// };
// /**
//  * Process paired queue until messengerDown occurs
//  * If paired queue processing fails to send a message, catch the exception and dispatch action for outage tracking
//  */
// export const processPairedQueueUntilDown = function* () {
//     for (;;) {
//         try {
//             // periodicProcessPairedMessageQueue never finishes, unless with an exception
//             // using race to cancel the processing on messengerDown
//             const result = yield race({
//                 messengerDown: take(messengerActions.messengerDown),
//                 pairedQueue: call(periodicProcessPairedMessageQueue)
//             });
//             if ('messengerDown' in result) {
//                 return;
//             }
//         } catch (error) {
//             if (error instanceof PairedQueueFailedMessage) {
//                 // action to kick-start outage tracking; which normally only periodically checks
//                 yield put(messengerActions.pairedQueueSendFailed());
//             } else {
//                 console.warn(`${LOG_PREFIX}::processPairedQueueUntilDown`, error);
//             }
//         }
//     }
// };
// export const WAIT_MESSENGER_RECONNECT_WHILE_DOWN_MS = 60_000;
// /**
//  * While messenger is down, periodically attempt issueing reconnects
//  */
// export const periodicMessengerReconnect = function* () {
//     let reconnectCount = 0;
//     for (;;) {
//         yield delay(WAIT_MESSENGER_RECONNECT_WHILE_DOWN_MS);
//         // if messenger is ready to go, but this task has not been cancelled yet by messengerUp action, quit
//         if (state.messenger.isReadyPaired()) {
//             console.info(
//                 `${LOG_PREFIX}::periodicMessengerReconnect`,
//                 'Messenger ready for paired messages, check happened before messengerUp action received'
//             );
//             return;
//         }
//         console.info(
//             `${LOG_PREFIX}::periodicMessengerReconnect`,
//             `Attempting reconnect, previous attempts ${reconnectCount}`
//         );
//         state.messenger.reconnect();
//         reconnectCount += 1;
//     }
// };
// export const WAIT_BEFORE_EVALUATE_QUEUE_IN_MS = 1_000;
// /**
//  * Periodically peek at front of queue and check it
//  */
// export const periodicProcessPairedMessageQueue = function* (): any {
//     for (;;) {
//         yield delay(WAIT_BEFORE_EVALUATE_QUEUE_IN_MS);
//         if (state.pairedMessageQueue.size) {
//             yield call(processPairedMessageQueue);
//         }
//     }
// };
// /**
//  * Peek at front of queue
//  *
//  * If message at front of queue does not have a UUID or we should resend last message,
//  *  then send the message
//  *
//  * If message has not been acknowledged for a while (past EVALUATION_THRESHOLD) attempt recconnect to websockets
//  */
// export const processPairedMessageQueue = function* (): any {
//     const iterator: IterableIterator<UnacknowledgedMessage> = state.pairedMessageQueue[Symbol.iterator]();
//     const result: IteratorResult<UnacknowledgedMessage> = iterator.next();
//     if (result.done) {
//         state.resendLastPairedMessage = false;
//         return;
//     }
//     console.info(
//         `${LOG_PREFIX}::evaluatePairedMessage`,
//         `The unacknowledged queue has ${state.pairedMessageQueue.size} messages.  Top of queue has action: ${result.value.messageDetails.messageType} and uuid: ${result.value.uuid}.`
//     );
//     // If the message at the top of the queue does not have a uuid this means the previous send failed.
//     // If resend last paired message is true then we have triggered a reconnect.  If either of these
//     // conditions are true then we want to resend the top of the queue.
//     if (!result.value.uuid || state.resendLastPairedMessage) {
//         const newUuid: string | null = yield call(sendPairedMessage, result.value.messageDetails, {
//             skipAcknowledgment: false,
//             uuid: result.value.uuid
//         });
//         console.info(
//             `${LOG_PREFIX}::resendPairedMessage`,
//             `Sending oldest message in queue action: ${result.value.messageDetails.messageType}, starting uuid: ${result.value.uuid}, ending uuid: ${newUuid}`
//         );
//         if (newUuid) {
//             // If the message was not originally sent (indicated by the lack of a uuid)
//             // but we are now able to send, then attach the uuid so we can properly
//             // acknowledge the message.
//             if (!result.value.uuid) {
//                 result.value.uuid = newUuid;
//             }
//             // Turn off the resend if we successfully resent the message.
//             if (state.resendLastPairedMessage) {
//                 state.resendLastPairedMessage = false;
//             }
//         } else {
//             throw new PairedQueueFailedMessage();
//         }
//     } else {
//         const PAIRED_QUEUE_THRESHOLDS: TransportPairedQueueThresholds = state.messenger.getPairedQueueThresholds();
//         result.value.totalEvaluationCount += 1;
//         result.value.currentEvaluationCount += 1;
//         // If more than one cycle, emit websocket delay event
//         // only emit when exactly equal to 2, only one event possible per message
//         if (result.value.totalEvaluationCount === 2) {
//             yield put(
//                 healthAggregationActions.emitHealthEvent({
//                     isHealthy: false,
//                     state: WS_DELAY.name
//                 })
//             );
//             yield call(outageTracker.startTrackingNewOutage, AnalyticsTrackerEventName.PAIRED_QUEUE_UNACKNOWLEDGED);
//         }
//         if (result.value.totalEvaluationCount === 4) {
//             yield put(alertActions.setPairedQueueBackupAlert());
//         }
//         const TIME_WAITING_SECONDS: number =
//             (result.value.currentEvaluationCount * WAIT_BEFORE_EVALUATE_QUEUE_IN_MS) / 1000;
//         const OVERALL_TIME_WAITING_SECONDS: number =
//             (result.value.totalEvaluationCount * WAIT_BEFORE_EVALUATE_QUEUE_IN_MS) / 1000;
//         const ACTION: string = result.value.messageDetails.messageType;
//         if (result.value.currentEvaluationCount % PAIRED_QUEUE_THRESHOLDS.reconnect === 0) {
//             console.info(
//                 `${LOG_PREFIX}::evaluatePairedMessage`,
//                 `Attempting reconnect, unacked ${ACTION} after ${TIME_WAITING_SECONDS} seconds; overall ${OVERALL_TIME_WAITING_SECONDS} seconds`
//             );
//             // allow message to be re-sent on the next evaluation
//             state.resendLastPairedMessage = true;
//             // reset the reconnect evaluation counter
//             result.value.currentEvaluationCount = 0;
//             // trigger a reconnect on the current transport
//             yield call(state.messenger.reconnect, result.value.uuid);
//             yield put(messengerActions.pairedQueueIssueReconnect());
//             yield call(analyticsTracker.track, AnalyticsTrackerEventName.PAIRED_QUEUE_RECONNECT_TRANSPORT);
//         } else if (result.value.currentEvaluationCount % PAIRED_QUEUE_THRESHOLDS.resend === 0) {
//             console.info(
//                 `${LOG_PREFIX}::evaluatePairedMessage`,
//                 `Attempting message resend, unacked ${ACTION} after ${TIME_WAITING_SECONDS} seconds; overall ${OVERALL_TIME_WAITING_SECONDS} seconds`
//             );
//             state.resendLastPairedMessage = true;
//         }
//     }
// };
// /**
//  * Handle acknowledgement of a paired message.
//  *
//  * Remove the message from the queue, dispatch confirmation action, and send the next message in the queue
//  */
// export const acknowledgePairedMessage = function* (acknowledgment: Acknowledgment) {
//     const iterator: IterableIterator<UnacknowledgedMessage> = state.pairedMessageQueue[Symbol.iterator]();
//     let result: IteratorResult<UnacknowledgedMessage> = iterator.next();
//     // check if iterator is empty
//     if (result.done) {
//         console.info(
//             `${LOG_PREFIX}::acknowledgeMessage`,
//             `No unacknowledged messages in queue, uuid: ${acknowledgment.uuid}`
//         );
//         return;
//     }
//     const MESSAGE: UnacknowledgedMessage = result.value;
//     // make sure the acknowledgment we got was for the expected message
//     if (MESSAGE.uuid !== acknowledgment.uuid) {
//         console.info(
//             `${LOG_PREFIX}::acknowledgeMessage`,
//             `Could not find unacknowledged message for uuid: ${acknowledgment.uuid}`
//         );
//         return;
//     }
//     // dispatch session mismatch if unexpected session id from acknowledgment
//     const SESSION_ID: string | null = analyticsTracker.getCommonEventProperty(
//         AnalyticsTrackerEventProperty.SESSION_ID
//     );
//     if ('sessionId' in acknowledgment && SESSION_ID !== acknowledgment.sessionId) {
//         yield put(messengerActions.sessionMismatch(SESSION_ID, acknowledgment.sessionId));
//     }
//     // delete message from the queue
//     console.info(
//         `${LOG_PREFIX}::acknowledgeMessage`,
//         `Removing acknowledge message uuid: ${acknowledgment.uuid} action: ${MESSAGE.messageDetails.messageType}`
//     );
//     state.pairedMessageQueue.delete(MESSAGE);
//     // See processPairedMessageQueue for the start of the outage.
//     yield call(
//         outageTracker.stopTrackingAndReportOpenOutage,
//         AnalyticsTrackerEventName.PAIRED_QUEUE_UNACKNOWLEDGED
//     );
//     // The confirmation is an arbitrary action that can be dispatched after the message
//     // is acknowledged.  This allows for blocking the application progression and then proceeding
//     // once the message is acknowledged.
//     if (MESSAGE.confirmation) {
//         console.info(
//             `${LOG_PREFIX}::acknowledgeMessage`,
//             `Sending confirmation for acknowledged message for uuid: ${acknowledgment.uuid}`
//         );
//         yield put(MESSAGE.confirmation as ActionType<object>);
//     }
//     result = iterator.next();
//     if (!result.done && result.value.uuid === null) {
//         // Send the next message in the queue if there is one
//         result.value.uuid = yield call(sendPairedMessage, result.value.messageDetails, {
//             skipAcknowledgment: false,
//             uuid: null
//         });
//     } else {
//         // this happens very often, and causes a lot of things to happen
//         // some re-rendering, plus invoking alerts synchronization
//         if (yield select(getIsPairedQueueBackup)) {
//             yield put(alertActions.clearPairedQueueBackupAlert());
//         }
//     }
// };
