import { median } from 'mathjs';
import * as moment from 'moment';
//import { call } from 'redux-saga/effects';
//import { ActionType } from 'typesafe-actions';
import { state } from './state';
import {
    SentMessage,
    SentMessageStatistics,
    SentMessageStatisticsPerTransport,
    TransportStatistics
} from '@fivestars-pos-sdk/types'
//import { log } from '@instore/utils/log';
// AB todo: implement log above line
import { BestTransportOrder } from './bestTransportOrder';

export const LOG_PREFIX = 'Messenger::stats';
export const UNACKNOWLEDGED_MARKER = -1;

// export const getStatsWindowStart = (): number => {
//     return state.messenger.getStatsWindowStart();
// };

/**
 * Package each transports statistics
 */
// export const getTransportStatistics = (endTime: number): TransportStatistics => {
//     return state.messenger.getTransportStatistics(endTime);
// };

// export const getBestTransportOrder = (): BestTransportOrder | null => {
//     return state.messenger.getBestTransportOrder();
// };

/**
 * Calculate sent message statistics using the sent messages
 */
// export const getSentMessageStatistics = (startTime: number, endTime: number): SentMessageStatisticsPerTransport => {
//     // build up object of sent messages per transport return
//     return Object.entries(state.messenger.getSentMessages()).reduce<SentMessageStatisticsPerTransport>(
//         (prev, [transportType, sentMessages]: [string, SentMessages]) => ({
//             ...prev,
//             [transportType]: _getSentMessageStatisticsForTransport(startTime, endTime, sentMessages)
//         }),
//         {} as SentMessageStatisticsPerTransport
//     );
// };

// export const _getSentMessageStatisticsForTransport = (
//     startTime: number,
//     endTime: number,
//     sentMessages: SentMessages
// ): SentMessageStatistics => {
//     let maxSentTime = 0;
//     let minSentTime = 0;
//     const roundTripDurations: number[] = [];

//     Object.entries(sentMessages).forEach(([_uuid, sentMessage]: [string, SentMessage]) => {
//         // do not count messages that don't fit into this stats period
//         // or messages that skipped acknowledgement (not a crucial transaction message)
//         if (sentMessage.sentTime > endTime || sentMessage.skipAcknowledgment) {
//             return;
//         }

//         if (minSentTime === 0 || minSentTime > sentMessage.sentTime) {
//             minSentTime = sentMessage.sentTime;
//         }

//         if (maxSentTime < sentMessage.sentTime) {
//             maxSentTime = sentMessage.sentTime;
//         }

//         if (sentMessage.responseTime) {
//             const ROUNDTRIP_DURATION: number = sentMessage.responseTime - sentMessage.sentTime;
//             roundTripDurations.push(ROUNDTRIP_DURATION);
//         } else {
//             // We use this marker to indicate there was not a response
//             // for this message.  The getDurationStats function will
//             // filter it out for most metrics.  It will be used for
//             // the count of unacknowledged.
//             roundTripDurations.push(UNACKNOWLEDGED_MARKER);
//             console.info(`${LOG_PREFIX}::getSentMessageStatistics::unacknowledged`, sentMessage);
//         }
//     });

//     const {
//         countAcknowledged,
//         countUnacknowledged,
//         avgDuration,
//         maxDuration,
//         minDuration,
//         medianDuration
//     } = getDurationStats(roundTripDurations);
//     const STATS: SentMessageStatistics = {
//         averageRoundtripDuration: avgDuration,
//         countAcknowledged,
//         countUnacknowledged,
//         endTime,
//         maxDuration,
//         maxSentDateTime: moment.utc(maxSentTime).toString(),
//         maxSentTime,
//         medianRoundtripDuration: medianDuration,
//         minDuration,
//         minSentDateTime: moment.utc(minSentTime).toString(),
//         minSentTime,
//         minToMaxDuration: maxSentTime - minSentTime,
//         periodDuration: endTime < startTime ? 0 : endTime - startTime,
//         startTime
//     };

//     return STATS;
// };

export type DurationStats = {
    avgDuration: number;
    maxDuration: number;
    minDuration: number;
    medianDuration: number;
    totalDuration: number;
    countAcknowledged: number;
    countUnacknowledged: number;
    countUnder10: number;
    countUnder50: number;
    countUnder100: number;
    countUnder250: number;
    countUnder500: number;
    countUnder1000: number;
    countUnder2000: number;
    countUnder3000: number;
    count3000Plus: number;
    totalCountUnder250: number;
    totalCount250Plus: number;
    totalCount1000Plus: number;
};

export const getDurationStats = (roundTripDurations: number[]): DurationStats => {
    const durationStats: DurationStats = {
        avgDuration: 0,
        count3000Plus: 0,
        countAcknowledged: 0,
        countUnacknowledged: 0,
        countUnder10: 0,
        countUnder100: 0,
        countUnder1000: 0,
        countUnder2000: 0,
        countUnder250: 0,
        countUnder3000: 0,
        countUnder50: 0,
        countUnder500: 0,
        maxDuration: 0,
        medianDuration: 0,
        minDuration: 0,
        totalCount1000Plus: 0,
        totalCount250Plus: 0,
        totalCountUnder250: 0,
        totalDuration: 0
    };

    const COMPLETE_DURATIONS: number[] = roundTripDurations
        .filter((duration: number) => duration !== UNACKNOWLEDGED_MARKER)
        .sort((a: number, b: number) => a - b);

    if (COMPLETE_DURATIONS.length) {
        durationStats.minDuration = COMPLETE_DURATIONS[0];
        durationStats.maxDuration = COMPLETE_DURATIONS[COMPLETE_DURATIONS.length - 1];
        durationStats.totalDuration = Math.round(COMPLETE_DURATIONS.reduce((a: number, b: number) => a + b, 0));
        durationStats.avgDuration = Math.round(durationStats.totalDuration / COMPLETE_DURATIONS.length);
        durationStats.medianDuration = Math.round(median(COMPLETE_DURATIONS));
    }

    roundTripDurations.forEach((duration: number) => {
        if (duration === UNACKNOWLEDGED_MARKER) {
            durationStats.countUnacknowledged += 1;
        } else {
            durationStats.countAcknowledged += 1;

            if (duration < 10) {
                durationStats.countUnder10 += 1;
            } else if (duration < 50) {
                durationStats.countUnder50 += 1;
            } else if (duration < 100) {
                durationStats.countUnder100 += 1;
            } else if (duration < 250) {
                durationStats.countUnder250 += 1;
            } else if (duration < 500) {
                durationStats.countUnder500 += 1;
            } else if (duration < 1000) {
                durationStats.countUnder1000 += 1;
            } else if (duration < 2000) {
                durationStats.countUnder2000 += 1;
            } else if (duration < 3000) {
                durationStats.countUnder3000 += 1;
            } else {
                durationStats.count3000Plus += 1;
            }

            if (duration < 250) {
                durationStats.totalCountUnder250 += 1;
            } else {
                if (duration > 1000) {
                    durationStats.totalCount1000Plus += 1;
                }

                durationStats.totalCount250Plus += 1;
            }
        }
    });

    return durationStats;
};

/**
 * Saga: Used as the onSuccess action for IHS heartbeat
 *
 * Clear out the internal stats counters in the websocket client,
 * so we can start collecting stats for the next heartbeat
 */
// export const resetStats = function* (action: ActionType<typeof messengerActions.resetStats>) {
//     yield call(state.messenger.resetStats, action.payload.endTime);
// };
// AB todo: need to implement this above