import { EventEmitter } from 'events'
import { CONFIG } from '@fivestars-pos-sdk/config'
import { WebSocketTransport, WebRtcTransport, UdpTransport } from './transports'
import { 
    Acknowledgment,
    AnalyticsTrackerEventProperty,
    MessageAcknowledgment,
    MessageDetails, 
    MessageGeneral,
    PairedDevice,
    SendOptions,
    SentMessage,
    SentMessages,
    SentMessagesPerTransport,
    TransportStatistics,
    TransportType, 
    ILoyaltyCredentials,
    TransportPairedQueueThresholds,
    WebsocketConnectStatistics
} from '@fivestars-pos-sdk/types'
import { getPackedApiKey } from './utils/packedApiKey'
import { BestTransportOrder, getBestTransportOrder, TransportFactors } from './bestTransportOrder'
import { SkewAdjustedTime } from './utils/skewAdjustedTime';
import { Transport } from './transports/transport';
import { constructMessageGeneral, trackPairedMessageEvent } from './utils'
//import { analyticsTracker } from './utils/analyticsTracker';
import * as messengerActions from './actions'
//import { processBroadcastMessage } from './send/broadcast'
//import { handleErroneousPairing } from './send/erroneousPairing'
//import { processPairedMessage, sendSubscriberAuthenticated } from './send/paired'

export const LOG_PREFIX = 'Messenger';

export class Messenger extends EventEmitter {
    private loyaltyCredentials: ILoyaltyCredentials = {
        apiKey: '',
        apiSecret: '',
        softwareId: ''
    };

    private lastSendTransportType: TransportType = TransportType.WEB_SOCKET;
    private receivedMessages: Set<string> = new Set();
    private sentMessages: SentMessagesPerTransport = {
        Bluetooth: {},
        UDP: {},
        WebRtc: {},
        WebSocket: {}
    };
    private messageToTransports: { [uuid: string]: Set<TransportType> } = {};
    private statsWindowStart: number = SkewAdjustedTime.now();

    // convenience map, used to generate transport array when feature flag is set
    private transportsMap: Map<TransportType, Transport>;

    /**
     * The order the transports are tried when sending a message.  This can be set by
     * the messenger_transports feature flag. If a transport is ommited from the
     * feature flag, it will not be used.
     *
     * After initially setting the order we update it by analyzing the ping / pong
     * messages to see which transports are "best".
     */
    private transportOrder: Transport[];
    private bestTransportOrder: BestTransportOrder | null = null;

    constructor(
        public udpTransport: UdpTransport,
        public webSocketTransport: WebSocketTransport,
        public webRtcTransport: WebRtcTransport
    ) {
        super()
        console.log('Messenger::constructor')        

        this.transportsMap = new Map([
            [TransportType.UDP, udpTransport],
            [TransportType.WEB_SOCKET, webSocketTransport],
            [TransportType.WEB_RTC, webRtcTransport]
        ] as Iterable<[TransportType, Transport]>);

        this.transportOrder = [webRtcTransport, udpTransport, webSocketTransport];

        this.webRtcTransport.on("message", this.onWebRtcMsg)
        this.webSocketTransport.on("message", this.onWebSocketMsg)
        this.udpTransport.on("message", this.onUdpMsg)
    }

    public start = async (loyaltyCredentials: ILoyaltyCredentials): Promise<void> => {
        console.log("Messenger::start")        
        this.loyaltyCredentials = loyaltyCredentials;

        await this.webSocketTransport.start(loyaltyCredentials);
        await this.udpTransport.start(loyaltyCredentials);
        await this.webRtcTransport.start(loyaltyCredentials);

        this.emit("message", messengerActions.initialized())
    }

    public setDefaultTransportOrder(transportTypes: TransportType[]): void {
        console.log('Messenger::setDefaultTransportOrder')        

        if (this.shouldReplaceTransportOrder(transportTypes)) {
            this.setTransportOrder(transportTypes);
            this.bestTransportOrder = null;
        }
    }

    private shouldReplaceTransportOrder(transportTypes: TransportType[]): boolean {
        console.log('Messenger::shouldReplaceTransportOrder')        

        if (!this.bestTransportOrder) {
            return true;
        }

        if (this.bestTransportOrder.order.length !== transportTypes.length) {
            return true;
        }

        let shouldReplace = false;

        transportTypes.forEach((transportType: TransportType) => {
            if (this.bestTransportOrder && !this.bestTransportOrder.order.includes(transportType)) {
                shouldReplace = true;
            }
        });

        return shouldReplace;
    }

    private setTransportOrder(transportTypes: TransportType[]): void {
        console.log('Messenger::setTransportOrder')        

        if (!transportTypes.length) {
            console.warn(`${LOG_PREFIX}::setTransportOrder`, 'Attempting remove all transports.');
            return;
        }

        this.transportOrder = transportTypes
            .filter(_type => this.transportsMap.has(_type))
            .map(_type => this.transportsMap.get(_type) as Transport);
    }

    /**
     * Send data object using prioritized list of transports
     *
     * @param messageDetails The content to be sent
     * @param options Whether to skip aknowledgments and create a new uuid
     * @returns A promise that resolves to the UUID of the message sent or null if failed
     */
    public async sendPaired(messageDetails: MessageDetails, options: SendOptions): Promise<string | null> {
        console.log('Messenger::sendPaired')        

        const MESSAGE: MessageGeneral = constructMessageGeneral({ messageDetails, options });

        if (!MESSAGE.destination) {
            throw new Error('Destination must be set for paired message');
        }

        for (const transport of this.transportOrder) {
            if (!transport.isReadyPaired()) {
                continue;
            }

            try {
                console.info(`${LOG_PREFIX}::sendPaired::${transport.transportType}`, MESSAGE);
                await transport.send(MESSAGE);
                this.trackSentMessage(MESSAGE, options, transport.transportType);

                if (this.lastSendTransportType !== transport.transportType) {
                    // AB todo: implement this
                    // this.eventManager.eventEmitter(
                    //     messengerActions.switchTransport({
                    //         from: this.lastSendTransportType,
                    //         to: transport.transportType
                    //     })
                    // );
                    this.lastSendTransportType = transport.transportType;
                }
                return MESSAGE.uuid;
            } catch (error) {
                console.info(`${LOG_PREFIX}::sendPaired::${transport.transportType}`, error);
                transport.triggerReconnect();
            }
        }

        // we've iterated through all transports, and nothing sent the message!
        return null;
    }

        /**
     * Only send message through websocket server (for now)
     *
     * @param messageDetails The content to be sent
     * @param options Whether to skip aknowledgments and create a new uuid
     * @returns A promise that resolves to the UUID of the message sent or null if failed
     */
    public async sendBroadcast(messageDetails: MessageDetails): Promise<string | null> {
        console.log('Messenger::sendBroadcast')        

        const MESSAGE: MessageGeneral = constructMessageGeneral({ messageDetails });

        try {
            console.info(`${LOG_PREFIX}::sendBroadcast::${this.webSocketTransport.transportType}`, MESSAGE);
            await this.webSocketTransport.send(MESSAGE);
            return MESSAGE.uuid;
        } catch (error) {
            console.info(`${LOG_PREFIX}::sendBroadcast::${this.webSocketTransport.transportType}`, error);
            return null;
        }
    }

    private trackSentMessage(
        messageGeneral: MessageGeneral,
        sendOptions: SendOptions,
        transportType: TransportType
    ): void {
        console.log('Messenger::trackSentMessage')        

        if (messageGeneral.action === Acknowledgment || !messageGeneral.destination) {
            return;
        }

        const transportSentMessages: SentMessages = this.sentMessages[transportType];

        if (transportSentMessages[messageGeneral.uuid]) {
            transportSentMessages[messageGeneral.uuid].resendCount += 1;
            return;
        }

        transportSentMessages[messageGeneral.uuid] = {
            acknowledgedTime: null,
            payload: messageGeneral,
            reconnectCount: 0,
            resendCount: 0,
            responseTime: null,
            sentTime: SkewAdjustedTime.now(),
            skipAcknowledgment: sendOptions.skipAcknowledgment
        };

        if (!this.messageToTransports[messageGeneral.uuid]) {
            this.messageToTransports[messageGeneral.uuid] = new Set();
        }

        this.messageToTransports[messageGeneral.uuid].add(transportType);
    }

    private getLastUsedTransport(): Transport {
        console.log('Messenger::getLastUsedTransport')        

        return this.transportsMap.get(this.lastSendTransportType) || this.webSocketTransport;
    }

        /**
     * Called when acknowledgments are not coming in, initiates a reconnect on the current transport.
     *
     * @param uuid The identifier for the sent message that was stuck, prompting the reconnect
     * @returns void
     */
    public reconnect(uuid = ''): void {
        console.log('Messenger::reconnect')        

        const TRANSPORT: Transport = this.getLastUsedTransport();
        const transportSentMessages: SentMessages = this.sentMessages[TRANSPORT.transportType];

        if (transportSentMessages[uuid]) {
            transportSentMessages[uuid].reconnectCount += 1;
        }

        console.info(`${LOG_PREFIX}::reconnect`, `Calling triggerReconnect for transport ${TRANSPORT.transportType}`);
        // Initiate reconnect on the last transport that successfully sent a message
        TRANSPORT.triggerReconnect();
    }

    public getPairedQueueThresholds(): TransportPairedQueueThresholds {
        console.log('Messenger::getPairedQueueThresholds')        

        const TRANSPORT: Transport = this.getLastUsedTransport();
        return TRANSPORT.getPairedQueueThresholds();
    }

    /**
     * Acknowledgment Message Received callback
     * - update statistics for the sent message
     * - send acknowledgemnt action through eventManager
     *
     * @param message
     */
    public messageAcknowledgment(message: MessageAcknowledgment, acknowledgedByTransportType: TransportType): void {
        if (!message.data || !message.data.uuid || !message.data.acknowledgedTime) {
            console.warn(`${LOG_PREFIX}::messageAcknowledgment`, 'Received acknowledgment with invalid data.');
            console.info(`${LOG_PREFIX}::messageAcknowledgment`, message);
            return;
        }
        console.log('Messenger::messageAcknowledgment')        

        const SKIP_ACKNOWLEDGMENT: boolean = this.trackAcknowledgment(message, acknowledgedByTransportType);

        // If we are skipping the acknowledgment we do not need to broadcast when
        // the acknowledgment is received (ex., battery update)
        if (!SKIP_ACKNOWLEDGMENT) {
            // AB todo: implement below
//            this.eventManager.eventEmitter(messengerActions.acknowledgement(message.data));
            this.emit("message", messengerActions.initialized())
        }
    }

    private trackAcknowledgment(
        message: MessageAcknowledgment,
        acknowledgedByTransportType: TransportType
    ): boolean {
        console.log('Messenger::trackAcknowledgment')        

        const { uuid, acknowledgedTime } = message.data;

        if (!(uuid in this.messageToTransports)) {
            return false;
        }

        // default to emitting the acnowledgement action until we explicitly know it's not needed
        // we do not want a message to be stuck in the paired queue
        let skipAcknowledgment = false;

        this.messageToTransports[uuid].forEach((transportType: TransportType) => {
            const transportSentMessages: SentMessages = this.sentMessages[transportType];

            if (transportSentMessages && transportSentMessages[uuid]) {
                const SENT_MESSAGE: SentMessage = transportSentMessages[uuid];
                skipAcknowledgment = SENT_MESSAGE.skipAcknowledgment;

                // only go through this path if we haven't already seen an acknowledgment
                // and we are not skipping the acknowledgment
                if (!SENT_MESSAGE.responseTime && !skipAcknowledgment) {
                    // message exists in this transport's sent messages, update the data
                    SENT_MESSAGE.acknowledgedTime = acknowledgedTime;
                    SENT_MESSAGE.responseTime = SkewAdjustedTime.now();
                    trackPairedMessageEvent(uuid, SENT_MESSAGE, transportType, acknowledgedByTransportType);
                }
            } else {
                console.info(
                    `${LOG_PREFIX}::trackAcknowledgment`,
                    `Received acknowledgment on transport ${acknowledgedByTransportType} but missing record in sent message for transport ${transportType}.`
                );
                console.info(`${LOG_PREFIX}::messageAcknowledgment`, message);
            }
        });

        return skipAcknowledgment;
    }

        /**
     * Generic Message received callback
     * - pipe message through eventManager
     * - if message is a paired message, send an Acknowledgment
     *
     * @param message
     */
    public messageGeneral(message: MessageGeneral): void {
        console.log('Messenger::messageGeneral')        

        if (this.receivedMessages.has(message.uuid)) {
            console.info(`${LOG_PREFIX}::messageGeneral`, `Message already received. uuid: ${message.uuid}`);
        } else {
            // AB todo: implement this
            // this.eventManager.eventEmitter(
            //     messengerActions.messageReceived({
            //         destination: message.destination,
            //         messageData: message.data,
            //         messageType: `ws.${message.action}`,
            //         source: message.source,
            //         webappVersion: message.webappVersion
            //     })
            // );

            this.emit("message", messengerActions.messageReceived({
                destination: message.destination,
                messageData: message.data,
                messageType: `ws.${message.action}`,
                source: message.source,
                webappVersion: message.webappVersion
            }))

            if (message.uuid) {
                this.receivedMessages.add(message.uuid);
            }
        }

        // If it is a paired message then we want to acknowledge
        if (message.destination) {
            this.sendPaired(
                {
                    destination: message.source,
                    messageData: {
                        acknowledgedTime: SkewAdjustedTime.now(),
                        // AB todo: implement analytics
                        // sessionId: analyticsTracker.getCommonEventProperty(
                        //     AnalyticsTrackerEventProperty.SESSION_ID
                        // ),
                        sessionId: 0,
                        uuid: message.uuid
                    },
                    messageType: Acknowledgment,
                    source: message.destination,
                    webappVersion: CONFIG.VERSION.APP_VERSION
                },
                {
                    skipAcknowledgment: true,
                    uuid: null
                }
            );
        }
    }

    public getStatsWindowStart(): number {
        console.log('Messenger::getStatsWindowStart')        
        return this.statsWindowStart;
    }

    public getSentMessages(): SentMessagesPerTransport {
        console.log('Messenger::getSentMessages')        
        return this.sentMessages as SentMessagesPerTransport
    }

    /**
     * Prune sent messages, and set the time of the next window to start now
     */
    public resetStats(endTime: number): void {
        console.log('Messenger::resetStats')        
        // delete the sent messages
        Object.entries(this.getSentMessages()).forEach(([transportType, sentMessages]: [string, SentMessages]) => {
            Object.entries(sentMessages).forEach(([uuid, sentMessage]: [keyof SentMessages, SentMessage]) => {
                if (sentMessage.sentTime <= endTime) {
                    // if there is no response time then it was not acknowledged (at least on sent transport)
                    if (!sentMessage.responseTime && !sentMessage.skipAcknowledgment) {
                        trackPairedMessageEvent(uuid as string, sentMessage, transportType as TransportType);
                    }
                    delete this.sentMessages[transportType as TransportType][uuid]
                    delete this.messageToTransports[uuid]
                }
            });
        });

        this.statsWindowStart = endTime;

        this.transportsMap.forEach(transport => {
            transport.resetStats(endTime);
        });
    }

    public getTransportStatistics(endTime: number): TransportStatistics {
        console.log('Messenger::getTransportStatistics')        
        return {
            [TransportType.UDP]: this.udpTransport.getStats(endTime),
            [TransportType.WEB_RTC]: this.webRtcTransport.getStats(endTime),
            [TransportType.WEB_SOCKET]: this.webSocketTransport.getStats(endTime) as unknown as WebsocketConnectStatistics
        };
    }

    public applyBestTransportOrder(
        startTime: number,
        endTime: number,
        transportStatistcs: TransportStatistics
    ): void {
        console.log('Messenger::applyBestTransportOrder')        

        const CURRENT_TRANSPORT_ORDER: TransportType[] = this.transportOrder.map(
            (transport: Transport) => transport.transportType
        );

        if (!CURRENT_TRANSPORT_ORDER.length) {
            return;
        }

        const CURRENT_BEST_TRANSPORT_FACTORS: TransportFactors[] = this.bestTransportOrder
            ? this.bestTransportOrder.allTransportFactors.filter((transportFactors: TransportFactors) => {
                  return transportFactors.transportType === CURRENT_TRANSPORT_ORDER[0];
              })
            : [];

        this.bestTransportOrder = getBestTransportOrder(
            startTime,
            endTime,
            transportStatistcs,
            CURRENT_TRANSPORT_ORDER,
            CURRENT_BEST_TRANSPORT_FACTORS.length ? CURRENT_BEST_TRANSPORT_FACTORS[0] : null
        );
        this.setTransportOrder(this.bestTransportOrder.order);
    }

    public getBestTransportOrder(): BestTransportOrder | null {
        console.log('Messenger::getBestTransportOrder')        
        return this.bestTransportOrder;
    }

    public getSource(): string | null {
        console.log('Messenger::getSource')        
        return getPackedApiKey(this.loyaltyCredentials.apiKey);
    }

    public isReadyPaired(): boolean {
        console.log('Messenger::isReadyPaired')        

        for (const transport of this.transportOrder) {
            if (transport.isReadyPaired()) {
                return true;
            }
        }

        return false;
    }

    public async touchReadyTransports(): Promise<void> {
        console.log('Messenger::touchReadyTransports')        
        for (const transport of this.transportOrder) {
            if (transport.isReadyPaired()) {
                await transport.touch();
            }
        }
    }

    public setPairedDevice(pairedDevice: PairedDevice | null): void {
        console.log('Messenger::setPairedDevice', pairedDevice)
        this.transportsMap.forEach((transport: Transport) => {
            transport.setPairedDevice(pairedDevice);
        });
    }

    onWebRtcMsg = (message: any) => {
        console.debug("Messenger::onWebRtcMsg", message)
    }

    onWebSocketMsg = (message: any) => {
        console.debug("Messenger::onWebSocketMsg", message)
        // if (message.action === messengerActions.sendBroadcast(message)) {
        //     console.info(`${LOG_PREFIX}::onWebSocketMsg`, 'message.action === messengerActions.sendBroadcast()')
        // }
        // else if (message.action === messengerActions.sendWebSocketServer(message)) {
        //     console.info(`${LOG_PREFIX}::onWebSocketMsg`, 'message.action === messengerActions.sendWebSocketServer()')
        // }
        // else if (message.action === messengerActions.sendPaired(message)) {
        //     console.info(`${LOG_PREFIX}::onWebSocketMsg`, 'message.action === messengerActions.sendPaired()')
        // }
        // else {
        //     this.emit("message", message)
        // }
        this.emit("message", message)        
    }

    onUdpMsg = (message: any) => {
        console.debug("Messenger::onUdpMsg", message)
    }
}