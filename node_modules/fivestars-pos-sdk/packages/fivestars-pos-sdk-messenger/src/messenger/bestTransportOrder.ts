import { CONFIG } from '@fivestars-pos-sdk/config'
//import { CONFIG } from '@app/config';
// AB todo: implement config above
// import { PingPongDurationStats } from '@instore/middleware/messenger/transports/transport';
// import { TransportType } from '@instore/middleware/messenger/types';
// import { TransportStatistics } from '@instore/redux/messenger/types';
import { PingPongDurationStats, 
         TransportType, 
         TransportStatistics,
} from '@fivestars-pos-sdk/types'
import { Formatter } from './utils/formatter';

export type DurationScore = {
    avgVsBadFactor: number;
    positiveFactor: number;
    score: number;
    totalCountUnder250: number;
    totalCount250Plus: number;
    totalCount1000Plus: number;
};

export type TransportFactors = {
    actualCount: number;
    durationScore: DurationScore | null;
    expectedCount: number;
    isAcceptableMedian: boolean;
    isReliable: boolean;
    medianDuration: number | null;
    reliability: number | null;
    transportType: TransportType;
};

export enum BestTransportRule {
    MEDIAN = 'MEDIAN',
    NONE = 'NONE',
    ONE = 'ONE',
    RELIABILITY = 'RELIABILITY',
    SCORE = 'SCORE',
    STICKY = 'STICKY'
}

export type BestTransportOrder = {
    allTransportFactors: TransportFactors[];
    order: TransportType[];
    periodDuration: number;
    rule: BestTransportRule;
    switch: boolean;
};

export type FactorAggregation = {
    maxReliability: number;
    minMedianDuration: number;
};

export const getBestTransportOrder = (
    startTimeInMs: number,
    endTimeInMs: number,
    transportStatistcs: TransportStatistics,
    previousTransportOrder: TransportType[],
    previousBestTransportFactors: TransportFactors | null
): BestTransportOrder => {
    const bestTransportOrder: BestTransportOrder = {
        allTransportFactors: [],
        order: [],
        periodDuration: endTimeInMs - startTimeInMs,
        rule: BestTransportRule.NONE,
        switch: false
    };
    _initializeFactors(bestTransportOrder, transportStatistcs, previousTransportOrder);
    _setTransportFactorFlags(bestTransportOrder.allTransportFactors);
    _sortTransportFactors(bestTransportOrder.allTransportFactors, previousBestTransportFactors);
    _setOrder(bestTransportOrder, previousBestTransportFactors);

    return bestTransportOrder;
};

export const _initializeFactors = (
    bestTransportOrder: BestTransportOrder,
    transportStatistcs: TransportStatistics,
    previousTransportOrder: TransportType[]
): void => {
    // for (const transportType of previousTransportOrder) {
    //     const PING_PONG_DURATION_STATS: PingPongDurationStats | undefined =
    //         transportStatistcs[transportType]['pingPongDurationStats'];

    //     if (!PING_PONG_DURATION_STATS) {
    //         bestTransportOrder.allTransportFactors.push({
    //             actualCount: 0,
    //             durationScore: null,
    //             expectedCount: 0,
    //             isAcceptableMedian: false,
    //             isReliable: false,
    //             medianDuration: null,
    //             reliability: null,
    //             transportType
    //         });
    //         continue;
    //     }

    //     const TRANSPORT_FACTORS: TransportFactors = _getTransportFactors(
    //         transportType,
    //         bestTransportOrder.periodDuration,
    //         PING_PONG_DURATION_STATS
    //     );
    //     bestTransportOrder.allTransportFactors.push(TRANSPORT_FACTORS);
    // }
    // AB todo: need to implement above lines
};

export const _setTransportFactorFlags = (allTransportFactors: TransportFactors[]): void => {
    const factorAggregation: FactorAggregation = _getFactorAggregation(allTransportFactors);

    allTransportFactors.forEach((transportFactors: TransportFactors) => {
        if (
            transportFactors.reliability &&
            factorAggregation.maxReliability - transportFactors.reliability <
                CONFIG.MESSENGER.BEST_TRANSPORT.RELIABILITY_THRESHOLD
        ) {
            transportFactors.isReliable = true;
        }

        if (
            transportFactors.medianDuration &&
            (transportFactors.medianDuration < CONFIG.MESSENGER.BEST_TRANSPORT.MEDIAN_CEILING_IN_MS ||
                transportFactors.medianDuration / factorAggregation.minMedianDuration <
                    CONFIG.MESSENGER.BEST_TRANSPORT.MEDIAN_PCT_DIFF_THRESHOLD)
        ) {
            transportFactors.isAcceptableMedian = true;
        }
    });
};

export const _getFactorAggregation = (allTransportFactors: TransportFactors[]): FactorAggregation => {
    let maxReliability = 0.0;
    let minMedianDuration: number = Number.MAX_SAFE_INTEGER;

    allTransportFactors.forEach((transportFactors: TransportFactors) => {
        if (transportFactors.reliability && transportFactors.reliability > maxReliability) {
            maxReliability = transportFactors.reliability;
        }

        if (transportFactors.medianDuration && transportFactors.medianDuration < minMedianDuration) {
            minMedianDuration = transportFactors.medianDuration;
        }
    });

    return {
        maxReliability,
        minMedianDuration
    };
};

export const _sortTransportFactors = (
    allTransportFactors: TransportFactors[],
    previousBestTransportFactors: TransportFactors | null
): void => {
    allTransportFactors.sort(
        (currentTransportFactors: TransportFactors, previousTransportFactors: TransportFactors): number => {
            if (currentTransportFactors.isReliable && !previousTransportFactors.isReliable) {
                return -1;
            }

            if (!currentTransportFactors.isReliable && previousTransportFactors.isReliable) {
                return 1;
            }

            if (currentTransportFactors.isAcceptableMedian && !previousTransportFactors.isAcceptableMedian) {
                return -1;
            }

            if (!currentTransportFactors.isAcceptableMedian && previousTransportFactors.isAcceptableMedian) {
                return 1;
            }

            if (currentTransportFactors.durationScore && !previousTransportFactors.durationScore) {
                return -1;
            }

            if (!currentTransportFactors.durationScore && previousTransportFactors.durationScore) {
                return 1;
            }

            if (currentTransportFactors.durationScore && previousTransportFactors.durationScore) {
                if (currentTransportFactors.durationScore.score > previousTransportFactors.durationScore.score) {
                    return -1;
                }

                if (currentTransportFactors.durationScore.score < previousTransportFactors.durationScore.score) {
                    return 1;
                }
            }

            // A bunch of tie breakers
            if (currentTransportFactors.transportType === previousBestTransportFactors?.transportType) {
                return -1;
            }

            if (previousTransportFactors.transportType === previousBestTransportFactors?.transportType) {
                return 1;
            }

            if (currentTransportFactors.medianDuration && previousTransportFactors.medianDuration) {
                return currentTransportFactors.medianDuration - previousTransportFactors.medianDuration;
            }

            return 0;
        }
    );
};

export const _setOrder = (
    bestTransportOrder: BestTransportOrder,
    previousBestTransportFactors: TransportFactors | null
): void => {
    // Initialize the order with any transports that do not have pings
    bestTransportOrder.order = bestTransportOrder.allTransportFactors
        .filter((transportFactors: TransportFactors) => !transportFactors.actualCount)
        .map((transportFactors: TransportFactors) => transportFactors.transportType);
    const POSSIBLE_BEST_TRANSPORT_FACTORS: TransportFactors[] = bestTransportOrder.allTransportFactors.filter(
        (transportFactors: TransportFactors) => {
            return transportFactors.actualCount;
        }
    );

    // If there are no transports with pings then we exit immediately
    if (!POSSIBLE_BEST_TRANSPORT_FACTORS.length) {
        bestTransportOrder.switch = previousBestTransportFactors ? true : false;
        return;
    }

    const BEST_TRANSPORT_FACTOR: TransportFactors = POSSIBLE_BEST_TRANSPORT_FACTORS[0];
    const POSSIBLE_SWITCH: boolean =
        previousBestTransportFactors &&
        BEST_TRANSPORT_FACTOR.transportType !== previousBestTransportFactors.transportType
            ? true
            : false;

    // If there is only one transport with pings then that is the best
    if (POSSIBLE_BEST_TRANSPORT_FACTORS.length === 1) {
        bestTransportOrder.order.unshift(BEST_TRANSPORT_FACTOR.transportType);
        bestTransportOrder.rule = BestTransportRule.ONE;
        bestTransportOrder.switch = POSSIBLE_SWITCH;
        return;
    }

    const PENULTIMATE_TRANSPORT_FACTOR: TransportFactors = bestTransportOrder.allTransportFactors[1];

    // If the previous transport and penultimate are close in score and the best is close to the penultimate
    // then we keep the previous transport to avoid unnecessary flapping of the best transport
    if (previousBestTransportFactors) {
        if (_isRuleSticky(BEST_TRANSPORT_FACTOR, PENULTIMATE_TRANSPORT_FACTOR, previousBestTransportFactors)) {
            POSSIBLE_BEST_TRANSPORT_FACTORS.reverse().forEach((transportFactors: TransportFactors) => {
                if (transportFactors.transportType !== previousBestTransportFactors.transportType) {
                    bestTransportOrder.order.unshift(transportFactors.transportType);
                }
            });

            bestTransportOrder.order.unshift(previousBestTransportFactors.transportType);
            bestTransportOrder.rule = BestTransportRule.STICKY;
            bestTransportOrder.switch = false;
            return;
        }
    }

    // If we get here then the sort order defines the order for the transports
    POSSIBLE_BEST_TRANSPORT_FACTORS.reverse().forEach((transportFactors: TransportFactors) => {
        bestTransportOrder.order.unshift(transportFactors.transportType);
    });

    // Here we determine the appropriate rule to apply to the best transport
    if (_isRuleReliability(BEST_TRANSPORT_FACTOR, PENULTIMATE_TRANSPORT_FACTOR)) {
        bestTransportOrder.rule = BestTransportRule.RELIABILITY;
    } else if (_isRuleMedian(BEST_TRANSPORT_FACTOR, PENULTIMATE_TRANSPORT_FACTOR)) {
        bestTransportOrder.rule = BestTransportRule.MEDIAN;
    } else {
        bestTransportOrder.rule = BestTransportRule.SCORE;
    }

    bestTransportOrder.switch = POSSIBLE_SWITCH;
};

/*
 * When the previous transport and the penultimate transport scores are close and the best transport
 * and the penultimate are also very close then we prefer the penultimate so that we avoid transport
 * switching for small changes in score.
 *
 * @param {TransportFactors} bestTransportFactor - The current selection for best transport
 * @param {TransportFactors} penultimateTransportFactor - The second selection for best transport
 * @param {TransportFactors} previousBestTransportFactors - The previous selection for best transport
 */
export const _isRuleSticky = (
    bestTransportFactor: TransportFactors,
    penultimateTransportFactor: TransportFactors,
    previousBestTransportFactors: TransportFactors
): boolean => {
    return penultimateTransportFactor.transportType === previousBestTransportFactors.transportType &&
        bestTransportFactor.durationScore &&
        penultimateTransportFactor.durationScore &&
        previousBestTransportFactors.durationScore &&
        bestTransportFactor.durationScore.score - penultimateTransportFactor.durationScore.score <
            CONFIG.MESSENGER.BEST_TRANSPORT.STICKY_THRESHOLD &&
        previousBestTransportFactors.durationScore.score - penultimateTransportFactor.durationScore.score <
            CONFIG.MESSENGER.BEST_TRANSPORT.STICKY_THRESHOLD
        ? true
        : false;
};

/*
 * When the best transport is reliable and the penultimate transport is not reliable
 * then the rule applied was reliability.
 *
 * @param {TransportFactors} bestTransportFactor - The current selection for best transport
 * @param {TransportFactors} penultimateTransportFactor - The second selection for best transport
 */
export const _isRuleReliability = (
    bestTransportFactor: TransportFactors,
    penultimateTransportFactor: TransportFactors
): boolean => {
    return bestTransportFactor.isReliable && !penultimateTransportFactor.isReliable;
};

/*
 * When the best transport has an acceptable median and penultimate transport does not have an
 * acceptable median duration then the rule applied was median.  Also, if the scores for the
 * best transport and the penultimate transport are the same and the best transport has a lower
 * median duration than the penultimate we also applied the median rule.
 *
 * @param {TransportFactors} bestTransportFactor - The current selection for best transport
 * @param {TransportFactors} penultimateTransportFactor - The second selection for best transport
 */
export const _isRuleMedian = (
    bestTransportFactor: TransportFactors,
    penultimateTransportFactor: TransportFactors
): boolean => {
    return (
        (bestTransportFactor.isAcceptableMedian && !penultimateTransportFactor.isAcceptableMedian) ||
        (bestTransportFactor.durationScore?.score === penultimateTransportFactor.durationScore?.score &&
        bestTransportFactor.medianDuration &&
        penultimateTransportFactor.medianDuration &&
        bestTransportFactor.medianDuration < penultimateTransportFactor.medianDuration
            ? true
            : false)
    );
};

export const _getTransportFactors = (
    transportType: TransportType,
    periodDurationInMs: number,
    pingPongDurationStats: PingPongDurationStats
): TransportFactors => {
    // Since the ping timer and the heartbeat timer are not
    // synchronized, subtract one from expected to apply a
    // fudge factor when the last ping has received a pong.
    // Also, make sure expected is never zero as it is used
    // as a denominator.
    const EXPECTED_COUNT: number = Math.max(
        Math.round(periodDurationInMs / CONFIG.MESSENGER.PING_FREQUENCY_IN_MS) - 1,
        1
    );

    return {
        actualCount: pingPongDurationStats.countAcknowledged,
        durationScore: _getDurationScore(pingPongDurationStats),
        expectedCount: EXPECTED_COUNT,
        isAcceptableMedian: false,
        isReliable: false,
        medianDuration: pingPongDurationStats.medianDuration,
        reliability: _getReliability(EXPECTED_COUNT, pingPongDurationStats),
        transportType
    };
};

export const _getDurationScore = (pingPongDurationStats: PingPongDurationStats): DurationScore | null => {
    if (!pingPongDurationStats.countAcknowledged) {
        return null;
    }

    const POSITIVE_DURATION_FACTOR: number =
        (pingPongDurationStats.totalCountUnder250 / pingPongDurationStats.countAcknowledged) *
        CONFIG.MESSENGER.BEST_TRANSPORT.DURATION_SCORE.POSITIVE_WEIGHT;
    const AVG_VS_BAD_DURATION_FACTOR: number =
        pingPongDurationStats.totalCount250Plus > 2
            ? (1 - pingPongDurationStats.totalCount1000Plus / pingPongDurationStats.totalCount250Plus) *
              CONFIG.MESSENGER.BEST_TRANSPORT.DURATION_SCORE.AVG_VS_BAD_WEIGHT
            : CONFIG.MESSENGER.BEST_TRANSPORT.DURATION_SCORE.AVG_VS_BAD_WEIGHT;
    const SCORE: number = POSITIVE_DURATION_FACTOR + AVG_VS_BAD_DURATION_FACTOR;

    return {
        avgVsBadFactor: Formatter.formatToFixedPrecision(AVG_VS_BAD_DURATION_FACTOR, 2) as number,
        positiveFactor: Formatter.formatToFixedPrecision(POSITIVE_DURATION_FACTOR, 2) as number,
        score: Formatter.formatToFixedPrecision(SCORE, 2) as number,
        totalCount1000Plus: pingPongDurationStats.totalCount1000Plus,
        totalCount250Plus: pingPongDurationStats.totalCount250Plus,
        totalCountUnder250: pingPongDurationStats.totalCountUnder250
    };
};

export const _getReliability = (
    expectedCount: number,
    pingPongDurationStats: PingPongDurationStats
): number | null => {
    if (!pingPongDurationStats.countAcknowledged) {
        return null;
    }

    // Max out reliability at 100%.  Note there is a little
    // ambiguity here because the count acknowledged and
    // the expected count are not completely synchronized.
    return Formatter.formatToFixedPrecision(
        Math.min(pingPongDurationStats.countAcknowledged / expectedCount, 1.0),
        2
    );
};
