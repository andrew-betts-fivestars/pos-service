export { Messenger } from './messenger'
export * from './transports'
import {
    ILoyaltyCredentials,
    WebSocketError
} from '@fivestars-pos-sdk/types'
//import { Channel } from 'redux-saga';
//import { actionChannel, all, call, fork, put, race, select, take, takeEvery } from 'redux-saga/effects';
//import { ActionType } from 'typesafe-actions';

//import { WebSocketError } from '@instore/middleware/messenger/transports/websocket/types';
//import { ILoyaltyCredentials } from '@instore/redux/authentication/types';
//import * as featuresActions from '@instore/redux/features/actions';
//import { getMessengerTransports } from '@instore/redux/features/selectors';
// import * as messengerActions from './actions'
// import { StartupCondition, startupConditions } from '@instore/redux/startupConditions'
// import * as systemActions from '@instore/redux/system/actions';
// import { analyticsTracker } from '@instore/utils/analyticsTracker';
// import { delay } from '@instore/utils/delay';
// import { AnalyticsTrackerEventName, AnalyticsTrackerEventProperty } from '@instore/utils/enums';
// import { log } from '@instore/utils/log';
// import { retryWithBackOff } from '@instore/utils/retryWithBackOff';
// import { storage } from '@instore/utils/storage';
// import { Validator } from '@instore/utils/validator';

// import { setPairedDevice } from './pairedDevice';
// import { watcher as pairedQueueWatcher } from './pairedQueue';
// import { watcher as sendWatcher } from './send';
// import { initializeMessengerState, state } from './state';
// import { resetStats } from './stats';
// import { watcher as touchWatcher } from './touch';
// import * as transportWatchers from './transports';
// import { TransportType } from './types';
// import { watcher as versionWatcher } from './version';

export const LOG_PREFIX = 'messenger';

//export const watcher = function* ([FIRST_PAIR, START_FINISHED, WEBSOCKET_AUTH, MESSENGER_INIT]: [
export const watcher = function* (
//     StartupCondition.FIRST_PAIR,
//     StartupCondition.START_FINISHED,
//     StartupCondition.WEBSOCKET_AUTH,
//     StartupCondition.MESSENGER_INIT
// ]) {
) {    
//     yield call(startupConditions, [MESSENGER_INIT]);

//     yield all([
//         // start completely independent watchers
//         fork(sendWatcher),
//         fork(pairedQueueWatcher),
//         fork(touchWatcher),

//         fork(transportWatchers.bluetoothWatcher, [START_FINISHED]),
//         fork(transportWatchers.webSocketWatcher, [WEBSOCKET_AUTH]),
//         fork(transportWatchers.webRtcWatcher, [FIRST_PAIR, WEBSOCKET_AUTH]),
//         fork(transportWatchers.udpWatcher, [FIRST_PAIR, START_FINISHED]),

//         fork(versionWatcher, [START_FINISHED]),

//         fork(_watchSwitchTransportForAnalytics),

//         takeEvery(featuresActions.setFeatures, _setDefaultTransportOrder),
//         takeEvery(messengerActions.resetStats, resetStats),

//         fork(setPairedDevice)
//     ]);
};

// /**
//  * Start messenger with loyalty credentials
//  *
//  * Blocks until Messenger is connected and ready for use
//  *
//  * Currently, this means blocking until we receive a websocket auth success
//  * Open question on whether we SHOULD be blocking on websocket
//  */
export const startMessenger = function* (loyaltyCredentials: ILoyaltyCredentials) {
//     if (!Validator.validLoyaltyCredentials(loyaltyCredentials)) {
//         console.warn(`${LOG_PREFIX}::blockOnConnection`, 'Incomplete loyalty credentials.');
//         throw new Error('Incomplete loyalty credentials');
//     }

//     yield call(_initializeFromStorage);

//     // set up state.messenger
//     yield call(initializeMessengerState);

//     yield put(messengerActions.initialized());

//     // Keep trying to authenticate with WSS
//     yield call(
//         retryWithBackOff,
//         {
//             failureAction: systemActions.startHalted(),
//             fn: _startMessengerWaitForWebSocketAuth,
//             fnName: 'messenger::_startMessengerWaitForWebSocketAuth'
//         },
//         loyaltyCredentials
//     );
};

export const _initializeFromStorage = function* () {
//     const UDP_PORT: number | null = yield call(storage.getItem, storage.getKeys().UDP_PORT);

//     if (UDP_PORT) {
//         yield put(messengerActions.udp.updateUdpPort(UDP_PORT));
//     }

//     const BLUETOOTH_MAC_ADDRESS: string | null = yield call(
//         storage.getItem,
//         storage.getKeys().BLUETOOTH_MAC_ADDRESS
//     );

//     if (BLUETOOTH_MAC_ADDRESS) {
//         yield put(messengerActions.bluetooth.macAddress(BLUETOOTH_MAC_ADDRESS));
//     }
}

// type WebSocketAuthSuccess = ActionType<typeof messengerActions.webSocket.authenticationSuccessful>;

export function* _startMessengerWaitForWebSocketAuth(loyaltyCredentials: ILoyaltyCredentials) {
//     const WAIT_ON_AUTHENTICATION_MS = 60000;

//     // [INSTORE-556] make sure we do not miss the authentication successful action, in case call to messenger.start does not return before auth happens
//     const WS_AUTH_CHANNEL: Channel<WebSocketAuthSuccess> = yield actionChannel(
//         messengerActions.webSocket.authenticationSuccessful
//     );

//     // calls start on all transports
//     // WebSocketTransport will initiate authentication with WSS
//     yield call(state.messenger.start, loyaltyCredentials);

//     const RESULT = yield race({
//         authenticationFailure: take(messengerActions.webSocket.authenticationFailure),
//         authenticationSuccessful: take(WS_AUTH_CHANNEL),
//         timeout: call(delay, WAIT_ON_AUTHENTICATION_MS)
//     });

//     WS_AUTH_CHANNEL.close();

//     if ('timeout' in RESULT) {
//         const MESSAGE = 'Timed out waiting for web socket authentication.';
//         throw new WebSocketError(500, MESSAGE);
//     }

//     if (RESULT.authenticationFailure) {
//         const MESSAGE = 'Failed to authenticate the web socket.';
//         throw new WebSocketError(401, MESSAGE);
//     }

//     console.info(`${LOG_PREFIX}::_waitOnWebSocketAuthentication`, 'Authentication succeeded for the web socket.');
}

// /**
//  * Listens for switchTransport action; uses AnalyticsTracker timed events to capture the duration
//  */
export function* _watchSwitchTransportForAnalytics() {
//     yield take(systemActions.startFinished);

//     for (;;) {
//         // initiate timed even in analytics tracker
//         yield call(analyticsTracker.startTimedEvent, AnalyticsTrackerEventName.MESSENGER_UPDATE_TRANSPORT);

//         const ACTION: ActionType<typeof messengerActions.switchTransport> = yield take(
//             messengerActions.switchTransport
//         );
//         const { from, to } = ACTION.payload;

//         // finishes the timed event; ready to start the next timed event
//         yield call(analyticsTracker.track, AnalyticsTrackerEventName.MESSENGER_UPDATE_TRANSPORT, {
//             [AnalyticsTrackerEventProperty.START_STATE]: from,
//             [AnalyticsTrackerEventProperty.END_STATE]: to
//         });
//     }
}

//type SetFeaturesAction = ActionType<typeof featuresActions.setFeatures>;
/**
 * Select the new transports order from redux and update messenger
 */
//export function* _setDefaultTransportOrder(_action: SetFeaturesAction) {
export function* _setDefaultTransportOrder() {    
//     const TRANSPORTS: TransportType[] = yield select(getMessengerTransports);

//     if (TRANSPORTS.length) {
//         yield call(state.messenger.setDefaultTransportOrder, TRANSPORTS);
//     }
}
