import { CONFIG } from '@fivestars-pos-sdk/config'
import { instorePlugins } from '../../../instore-plugins'
import { 
    DgramModule,
    UdpEvent,
    InstoreWindow,
    Product
 } from '@fivestars-pos-sdk/types';
//import { Product } from '../../utils/enums';

type onMessage = (updEvent: UdpEvent) => void;

export const LOG_PREFIX = 'UdpSocket (browser)'

export class UdpSocket {
    static DEFAULT_PORT = 49152;
    static IS_BROADCAST = true;
    static BROADCAST_IP = '255.255.255.255';
    static instoreWindow: InstoreWindow = window

    constructor(private plugin: DgramModule.Dgram = instorePlugins.dgram!) {
    }

    public open(port: number): Promise<void> {
        if (CONFIG.PRODUCT === Product.WINPAY) {
            return new Promise((resolve, reject) => {
                UdpSocket.instoreWindow.cef_udpMessenger.open(port, UdpSocket.IS_BROADCAST, resolve, reject);
            });
        }

        return this.plugin.open(port);
    }

    public listen(onMessage: onMessage, onError: (errorMessage: string) => void): void {
        if (CONFIG.PRODUCT === Product.WINPAY) {
            UdpSocket.instoreWindow.cef_udpMessenger.listen(onMessage, onError);
        } else {
            this.plugin.listen(onMessage, onError);
        }
    }

    public send(message: string, address: string, port: number): Promise<void> {
        if (CONFIG.PRODUCT === Product.WINPAY) {
            return new Promise((resolve, reject) => {
                UdpSocket.instoreWindow.cef_udpMessenger.send(message, address, port, resolve, reject);
            });
        }

        return this.plugin.send(message, address, port);
    }

    public close(): Promise<void> {
        if (CONFIG.PRODUCT === Product.WINPAY) {
            return new Promise((resolve, reject) => {
                // Currently doesn't take callbacks as parameters
                UdpSocket.instoreWindow.cef_udpMessenger.stopListening(resolve, reject);
            });
        }

        return this.plugin.close();
    }
}
