import { EncryptedTransport } from '../encryptedTransport'
import { isBrowser, isNode } from 'browser-or-node';
import {
    BroadcastDevice,
    Message,
    MessageGeneral,
    UdpStats,
    TransportType,
    UdpAction,
    UdpBroadcastStats,
    UdpEvent,
    UdpMessageExtra,
    LISTENER_STARTED
} from '@fivestars-pos-sdk/types';
import { UdpSocket } from './udpSocket-node';
import { constructMessageGeneral } from '../../utils';
//import * as messengerActions from '@instore/redux/messenger/actions';
//import { log } from '@instore/utils/log';
import { SkewAdjustedTime } from '../../utils/skewAdjustedTime'
import * as messengerActions from '../../actions';

export const LOG_PREFIX = 'UdpTransport';

export class UdpTransport extends EncryptedTransport<UdpMessageExtra> {
    public transportType: TransportType = TransportType.UDP;
    protected reconnectThreshold = 6;
    protected resendThreshold = 1;

    public isListening = false;
    public pairedDeviceAvailable = false;

    public lastReceivedPairedBroadcast: BroadcastDevice | null = null;
    private broadcastStats: UdpBroadcastStats = {
        pairedReceived: 0,
        sent: 0,
        sentFailed: 0,
        thisDeviceReceived: 0,
        totalReceived: 0
    };
    private udpSocket: UdpSocket;

    constructor() {
        // the ignore is because jest has trouble
        // with super and complains about an
        // uncovered branch
        // https://github.com/gotwarlost/istanbul/issues/690
        super() /* istanbul ignore next */;
        console.debug("UdpTransport::constructor")
        this.udpSocket = new UdpSocket();
    }

    public async openSocket(port: number): Promise<void> {
        console.debug("UdpTransport::openSocket")                                        
        try {
            await this.udpSocket.open(port);
            this.onOpenCallback();
          this.dispatchAction(messengerActions.udp.updateUdpPort(port));
        } catch (error) {
            console.info(`${LOG_PREFIX}::openSocket`, error);
        }
    }

    public async stop(): Promise<void> {
        console.debug("UdpTransport::stop")                                        
        try {
            this.isOpen = false;
            this.isListening = false;
            this.pairedDeviceAvailable = false;

            await this.udpSocket.close();
          this.dispatchAction(messengerActions.udp.stopped());
        } catch (error) {
            console.info(`${LOG_PREFIX}::stop`, error);
        }
    }

    public isReady(): boolean {
        console.debug("UdpTransport::isReady")                                                        
        return this.isOpen && this.isListening;
    }

    public isReadyPaired(): boolean {
        console.debug("UdpTransport::isReadyPaired")                                                        
        return this.isReady() && this.pairedDeviceAvailable;
    }

    protected onOpenCallback(): void {
        console.debug("UdpTransport::onOpenCallback")                                                                
        this.udpSocket.listen(this.onMessage, this.onErrorCallback);
        this.isOpen = true;
    }

    protected onErrorCallback(errorEvent: any): void {
        console.info(`${LOG_PREFIX}::onErrorCallback`, errorEvent);

        this.triggerReconnect();
    }

    public triggerReconnect(): void {
        console.debug("UdpTransport::triggerReconnect")                                                                

      this.dispatchAction(messengerActions.udp.reconnectRequest());
    }

    public handleTransportSpecificMessage(message: Message, extra: UdpMessageExtra): boolean {
        console.debug("UdpTransport::handleTransportSpecificMessage", message)                                                                
        switch (message.action) {
            case UdpAction.PING:
                this.sendPong(message.uuid);
                this.pingPongStats.pingReceived += 1;
                return true;
            case UdpAction.PONG:
                this.trackPongReceived(message);
              this.dispatchAction(messengerActions.udp.pongReceived());
                return true;
            case UdpAction.BROADCAST_API_KEY:
                this.onApiKeyBroadcast(message.data['apiKey'] as string, extra);
                return true;
            default:
                return false;
        }
    }

    private onMessage(updEvent: UdpEvent): void {
        console.debug("UdpTransport::onMessage", updEvent)                                                                        
        const MESSAGE: string = updEvent.message;

        // comes from the Udp plugin, not a real message from a paired device
        if (MESSAGE === LISTENER_STARTED) {
            console.info(`${LOG_PREFIX}::onMessage`, `The UDP Listener has successfully started.`);
            this.isListening = true;

            return;
        }

        this.onMessageCallback(MESSAGE, {
            socketAddress: {
                address: updEvent.address,
                port: updEvent.port
            }
        });
    }

    public send(messageGeneral: MessageGeneral): Promise<void> {
        console.debug("UdpTransport::send", messageGeneral)                                                                                
        if (!this.udpSocket) {
            return Promise.reject(new Error('The UDP socket is not set.'));
        }

        if (!this.lastReceivedPairedBroadcast) {
            return Promise.reject(new Error('The paired device has not yet been discovered.'));
        }

        return this.udpSocket.send(
            this.encrypt(messageGeneral),
            this.lastReceivedPairedBroadcast.socketAddress.address,
            this.pairedDevice?.udpPort ?? UdpSocket.DEFAULT_PORT
        );
    }

    public sendApiKeyBroadcast(): Promise<void> {
        console.debug("UdpTransport::sendApiKeyBroadcast")                                                                                                
        if (!this.udpSocket) {
            console.info(LOG_PREFIX, 'The UDP socket is not set');
            return Promise.reject(new Error('The UDP socket is not set'));
        }
        const API_KEY_MESSAGE: MessageGeneral = constructMessageGeneral({
            action: UdpAction.BROADCAST_API_KEY,
            data: { apiKey: this.loyaltyCredentials.apiKey }
        });

        return this.udpSocket
            .send(this.loyaltyCredentials.apiKey, UdpSocket.BROADCAST_IP, UdpSocket.DEFAULT_PORT)
            .then(() => {
                return this.udpSocket.send(
                    JSON.stringify(API_KEY_MESSAGE),
                    UdpSocket.BROADCAST_IP,
                    UdpSocket.DEFAULT_PORT
                );
            })
            .then(() => {
                if (this.pairedDevice?.udpPort && this.pairedDevice.udpPort !== UdpSocket.DEFAULT_PORT) {
                    return this.udpSocket.send(
                        JSON.stringify(API_KEY_MESSAGE),
                        UdpSocket.BROADCAST_IP,
                        this.pairedDevice.udpPort
                    );
                }

                return Promise.resolve();
            });
    }

    private onApiKeyBroadcast(apiKey: string, udpData: UdpMessageExtra): void {
        console.debug("UdpTransport::onApiKeyBroadcast")                                                                                                
        this.broadcastStats.totalReceived += 1;

        const BROADCAST_DEVICE: BroadcastDevice = {
            apiKey,
            receivedTimeInMs: SkewAdjustedTime.now(),
            socketAddress: udpData.socketAddress
        };

        // the broadcasted apiKey was our own
        if (BROADCAST_DEVICE.apiKey === this.loyaltyCredentials.apiKey) {
            this.broadcastStats.thisDeviceReceived += 1;
        }

        // the broadcasted apiKey was for our paired device
        if (this.pairedDevice && BROADCAST_DEVICE.apiKey === this.pairedDevice.apiKey) {
            this.broadcastStats.pairedReceived += 1;
            this.lastReceivedPairedBroadcast = BROADCAST_DEVICE;
          this.dispatchAction(messengerActions.udp.receivedPairedDeviceBroadcast());
        }
    }

    /**
     * Sends a connection test ping to the paired device's IP
     */
    public async sendPing(): Promise<void> {
        console.debug("UdpTransport::sendPing")                                                                                                                
        const MESSAGE: MessageGeneral = constructMessageGeneral({
            action: UdpAction.PING
        });

        try {
            await this.send(MESSAGE);
            this.trackPingSent(MESSAGE);
        } catch (error) {
            console.info(`${LOG_PREFIX}::sendPing`, error);
            this.pingPongStats.pingSentFailed += 1;
        }
    }

    /**
     * Respond to a connection test ping
     */
    private async sendPong(uuid: string): Promise<void> {
        console.debug("UdpTransport::sendPong")                                                                                                                
        const MESSAGE: MessageGeneral = constructMessageGeneral({
            action: UdpAction.PONG,
            uuid
        });
        try {
            await this.send(MESSAGE);
            this.pingPongStats.pongSent += 1;
        } catch (error) {
            console.info(`${LOG_PREFIX}::sendPong`, error);
            this.pingPongStats.pongSentFailed += 1;
        }
    }

    public incrementBroadcastSent(): void {
        console.debug("UdpTransport::incrementBroadcastSent")                                                                                                                

        this.broadcastStats.sent += 1;
    }

    public incrementBroadcastSentFailed(): void {
        console.debug("UdpTransport::incrementBroadcastSentFailed")                                                                                                                        
        this.broadcastStats.sentFailed += 1;
    }

    public getStats(endTime: number): UdpStats {
        console.debug("UdpTransport::getStats")
        return {
            broadcastStats: { ...this.broadcastStats },
            pingPongDurationStats: { ...this.getPingPongDurationStats(endTime) },
            pingPongStats: { ...this.pingPongStats }
        };
    }

    public resetStats(endTime: number): void {
        console.debug("UdpTransport::resetStats")

        super.resetStats(endTime);
        this.broadcastStats = {
            pairedReceived: 0,
            sent: 0,
            sentFailed: 0,
            thisDeviceReceived: 0,
            totalReceived: 0
        };
    }

    /**
     * Called by connection sagas when connection between paired devices is confirmed
     */
    public setPairedDeviceAvailable(isAvailable: boolean): void {
        console.debug("UdpTransport::setPairedDeviceAvailable ", isAvailable)        
        this.pairedDeviceAvailable = isAvailable;
    }

    public parse(message: string): Message | null {
        console.debug("UdpTransport::parse ", message)                
        try {
            const MESSAGE: Message = JSON.parse(message);
            return MESSAGE['action'] === UdpAction.BROADCAST_API_KEY ? MESSAGE : null;
        } catch {console.log("UdpTransport::parse exception")}

        return super.parse(message);
    }

    public touch(): Promise<void> {
        console.debug("UdpTransport::touch ")                                
      this.dispatchAction(messengerActions.udp.sendPing());
        return Promise.resolve();
    }
}
