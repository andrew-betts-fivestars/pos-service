import { EventEmitter } from 'events'
import { ILoyaltyCredentials,
         Acknowledgment, 
         Message, 
         MessageAcknowledgment, 
         MessageGeneral,
         TransportPairedQueueThresholds, 
         TransportType,
         PairedDevice,
         WebsocketConnectStatistics
        } from '@fivestars-pos-sdk/types'
import { state } from '../state'
import { AuthModel, PairingModel } from '@fivestars-pos-sdk/fivestars-pos-sdk-storage'
import { DurationStats, getDurationStats, UNACKNOWLEDGED_MARKER } from '../../messenger/stats';
import * as messengerActions from '../actions'

// import { DurationStats, getDurationStats, UNACKNOWLEDGED_MARKER } from '@instore/middleware/messenger/stats';
// import { ILoyaltyCredentials } from '@instore/redux/authentication/types';
// import * as messengerActions from '@instore/redux/messenger/actions';
// import { Acknowledgment, Message, MessageAcknowledgment, MessageGeneral } from '@instore/redux/messenger/types';
// import { PairedDevice } from '@instore/redux/pairing/types';
// import { log } from '@instore/utils/log';
import { getApiKey } from '../utils/packedApiKey'
import { SkewAdjustedTime } from '../utils/skewAdjustedTime';

// import { TransportPairedQueueThresholds, TransportType } from '../types';

export const LOG_PREFIX = 'Transport';

export type PingPongEvent = {
    pingSentTimeInMs: number;
    pongReceiveTimeInMs: number | null;
};

export type PingPongEvents = {
    [uuid: string]: PingPongEvent;
};

export type PingPongStats = {
    pingSent: number;
    pingSentFailed: number;
    pingReceived: number;

    pongSent: number;
    pongSentFailed: number;
    pongReceived: number;
};

export type PingPongDurationStats = DurationStats;
/**
 * @template MessageExtra -- additional data reported by a transport's onMessageCallback to be forwarded
 *                           along to every hook in the message processing. E.g. IP Address and Port for a UDP message
 */
export class Transport<MessageExtra = Record<string, unknown>> extends EventEmitter {
    protected pairedDevice: PairedDevice | null = null;
    public isOpen = false;
    // passed into start method with the idea it can change
    protected loyaltyCredentials: ILoyaltyCredentials = { apiKey: '', apiSecret: '', softwareId: '' };

    /**
     * When defining a new transport, these properties should be overloaded
     */
    public transportType: TransportType = TransportType.WEB_SOCKET; // Defaulting to Websocket, but put the correct type in when subclassing
    protected reconnectThreshold = -1;
    protected resendThreshold = -1;

    protected pingPongEvents: PingPongEvents = {};

    protected pingPongStats: PingPongStats = {
        pingReceived: 0,
        pingSent: 0,
        pingSentFailed: 0,

        pongReceived: 0,
        pongSent: 0,
        pongSentFailed: 0
    };

    public start(loyaltyCredentials: ILoyaltyCredentials): Promise<void> {
        this.loyaltyCredentials = loyaltyCredentials;
        console.log('Transport::start ', loyaltyCredentials)
        return Promise.resolve();
    }

    public setPairedDevice(pairedDevice: PairedDevice | null) {
        console.log('Transport::setPairedDevice ', pairedDevice)
        this.pairedDevice = pairedDevice;
    }

    /*
     * Send data object via overridden channel
     * @param {MessageGeneral} [message] - The content to be sent
     * @returns {Promise<void>} indicating success or failure to send
     *
     * Note: A promise is necessary because some channels determine if the
     *       send failed asynchronously.
     */
    public send(_message: MessageGeneral): Promise<void> {
        console.log('Transport::send ', _message)
        return Promise.reject(new Error('The send method must be overridden.'));
    }

    /**
     * Denotes that a transport is open and ready to be used
     */
    public isReady(): boolean {
        console.log('Transport::isReady')
        return false;
    }

    public getPairedQueueThresholds(): TransportPairedQueueThresholds {
        console.log('Transport::getPairedQueueThresholds')
        return {
            reconnect: this.reconnectThreshold,
            resend: this.resendThreshold
        };
    }

    /**
     * An extra option for a transport that may be ready for use, but there is no guarantee yet
     * that the paired device is ready to accept messages on this transport
     *
     * e.g. UDP socket is opened and usable, but we haven't gotten confirmation from the other end
     *
     * By default, just uses isReady
     */
    public isReadyPaired(): boolean {
        console.log('Transport::isReadyPaired')
        return this.isReady();
    }

    public getIsOpen(): boolean {
        console.log('Transport::getIsOpen')
        return this.isOpen;
    }

    protected onOpenCallback(_event: any): void {
        console.log('Transport::onOpenCallback ', _event)
    }

    protected onCloseCallback(_event: any): void {
        console.log('Transport::onCloseCallback ', _event)
    }

    protected onErrorCallback(event: any) {
        console.log('Transport::onErrorCallback ', event)
        console.info(`${LOG_PREFIX}::onErrorCallback`, event)
    }

    protected onMessageCallback(message: any, extra?: MessageExtra): void {
        console.log('Transport::onMessageCallback ', message)

        // If necessary this is overridden in the child class
        const MESSAGE: Message | null = this.parse(message, extra);
        if (!MESSAGE) {
            console.log('Transport::onMessageCallback !MESSAGE returning')
            return;
        }

        console.info(`${LOG_PREFIX}::onMessageCallback::${this.transportType}`, MESSAGE);

        // This is a private base class method that is applied
        // to all messages regardless of channel
        if (this.filterInvalidMessage(MESSAGE, extra)) {
            console.log('Transport::onMessageCallback filterInvalidMessage true returning')
            return;
        }

        // If necessary this is overridden in the child class
        if (this.filterMessage(MESSAGE, extra)) {
            console.log('Transport::onMessageCallback filterMessage true returning')
            return;
        }

        if (this.handleTransportSpecificMessage(MESSAGE, extra)) {
            console.log('Transport::onMessageCallback handleTransportSpecificMessage true returning')
            return;
        }

        if (MESSAGE.action === Acknowledgment) {
            console.log('Transport::onMessageCallback MESSAGE.action === Acknowledgment dispatchAction MESSAGE returning', MESSAGE)            
            // AB todo: need to implement this 
//            state.messenger.messageAcknowledgment(MESSAGE as MessageAcknowledgment, this.transportType);
            this.dispatchAction(MESSAGE)
            return;
        }

        // AB todo: need to implement this 
        console.log('Transport::onMessageCallback dispatchAction MESSAGE', MESSAGE)            
//       state.messenger.messageGeneral(MESSAGE);
        this.dispatchAction(MESSAGE)
    }

    protected parse(event: any, _extra?: MessageExtra): Message | null {
        console.log('Transport::parse ', event)        
        return JSON.parse(event);
    }

    /**
     * Makes sure that messages are valid before further processing
     * @param message
     * @returns boolean -- true, if message is invalid
     */
    private filterInvalidMessage(message: Message, _extra?: MessageExtra): boolean {
        console.log('Transport::filterInvalidMessage ', message)        

        if (!message.action) {
            console.log('Transport::filterInvalidMessage !message.action')

            console.warn(
                `${LOG_PREFIX}::filterMessage::${this.transportType}`,
                'Received a message without an action.'
            );
            return true;
        }

        const THIS_DEVICE_API_KEY: string | null = getApiKey(message.destination);

        if (THIS_DEVICE_API_KEY) {
            // If the destination is populated (i.e., it is a paired message)
            // then the embedded apikey must match this device.
//            if (THIS_DEVICE_API_KEY !== AuthModel.loyaltyCredentials.apiKey) {
            if (THIS_DEVICE_API_KEY !== this.loyaltyCredentials.apiKey) {                
                console.log(`Transport::filterInvalidMessage THIS_DEVICE_API_KEY=${THIS_DEVICE_API_KEY} `, message)                        
                return true;
            }

            // If it is a paired message and the source does not match the paired device then
            // dispatch the erroneous pairing action which will resolve the issue with the device
            // that erroneously thinks it is paired with this device.
            const PAIRED_DEVICE_API_KEY: string | null = getApiKey(message.source);
            if (
                PAIRED_DEVICE_API_KEY &&
                (!PairingModel.pairedDevice || PAIRED_DEVICE_API_KEY !== PairingModel.pairedDevice.apiKey)
            ) {
                // AB todo: implement this by emitting message for erroneousPairing

                if (this.pairedDevice) {
                    console.log(`Transport::filterInvalidMessage this.pairedDevice = ${this.pairedDevice} returning true`)            
                    this.dispatchAction(
                        messengerActions.erroneousPairing(THIS_DEVICE_API_KEY, PAIRED_DEVICE_API_KEY)
                    );
                }

                console.log(`Transport::filterInvalidMessage THIS_DEVICE_API_KEY = ${THIS_DEVICE_API_KEY} returning true`)            

                return true;
            }
        }
        else {
            console.log(`Transport::filterInvalidMessage THIS_DEVICE_API_KEY = ${THIS_DEVICE_API_KEY} returning false`)            
        }

        return false;
    }

    protected filterMessage(_message: Message, _extra?: MessageExtra): boolean {
        console.log('Transport::filterMessage ', _message)        

        return false;
    }

    protected handleTransportSpecificMessage(_message: Message, _extra?: MessageExtra): boolean {
        console.log('Transport::handleTransportSpecificMessage ', _message)        

        return false;
    }

    protected trackPingSent(message: Message): void {
        console.log('Transport::trackPingSent ', message)        

        this.pingPongEvents[message.uuid] = {
            pingSentTimeInMs: SkewAdjustedTime.now(),
            pongReceiveTimeInMs: null
        };
        this.pingPongStats.pingSent += 1;
    }

    protected trackPongReceived(message: Message): void {
        console.log('Transport::trackPongReceived ', message)        

        if (message.uuid in this.pingPongEvents) {
            const PING_PONG_EVENT = this.pingPongEvents[message.uuid];
            PING_PONG_EVENT['pongReceiveTimeInMs'] = SkewAdjustedTime.now();
        }
        this.pingPongStats.pongReceived += 1;
    }

    protected getPingPongDurationStats(endTime: number): PingPongDurationStats {
        console.log('Transport::getPingPongDurationStats ', endTime)        

        return getDurationStats(
            Object.values(this.pingPongEvents)
                // Events with a sent time that is after the end time
                // will be filtered out so that we do not erroneously
                // catalog them as unacknowledged when in fact we have
                // not given the pong enough time to arrive.  This is
                // an imperfect approach and the "pingSent" metric does
                // not apply this filter but for now it is good enough.
                .filter((pingPongEvent: PingPongEvent) => pingPongEvent.pingSentTimeInMs <= endTime)
                // Something likely happened with the clock skew and we want to exclude
                // negative durations as they are not helpful when picking a transport.
                .filter(
                    (pingPongEvent: PingPongEvent) =>
                        pingPongEvent.pongReceiveTimeInMs === null ||
                        pingPongEvent.pongReceiveTimeInMs > pingPongEvent.pingSentTimeInMs
                )
                .map((pingPongEvent: PingPongEvent) => {
                    // We use this marker to indicate there was not a response
                    // for this message.  The getDurationStats function will
                    // filter it out for most metrics.  It will be used for
                    // the count of unacknowledged.
                    if (!pingPongEvent.pongReceiveTimeInMs) {
                        return UNACKNOWLEDGED_MARKER;
                    }

                    return pingPongEvent.pongReceiveTimeInMs - pingPongEvent.pingSentTimeInMs;
                })
        );
    }

    public resetStats(endTime: number): void {
        console.log('Transport::resetStats', endTime)        

        Object.entries(this.pingPongEvents).forEach(([uuid, pingPongEvent]: [string, PingPongEvent]) => {
            if (pingPongEvent.pingSentTimeInMs <= endTime) {
                delete this.pingPongEvents[uuid];
            }
        });

        this.pingPongStats = {
            pingReceived: 0,
            pingSent: 0,
            pingSentFailed: 0,

            pongReceived: 0,
            pongSent: 0,
            pongSentFailed: 0
        };
    }

    public getStats(_endTime: number): object {
        console.log('Transport::getStats', _endTime)        

        return {};
    }

    /**
     * Emit Action onto EventManager - which eventually put into a redux-saga channel
     * The actions taken from this channel are dispatched into the rest of redux
     *
     * @param action
     */
//    protected dispatchAction(action: Record<string, unknown>): void {
    protected dispatchAction(action: any): void {        
        console.log('Transport::dispatchAction', action)        
        console.info(`${LOG_PREFIX}::dispatchAction::${this.transportType}`, action);
        this.emit('message', action)
//        state.messenger.eventManager.eventEmitter(action);
    }

    public triggerReconnect(): void {
        console.log('Transport::triggerReconnect')        
    }

    public touch(): Promise<void> {
        console.log('Transport::touch')        
        return Promise.resolve();
    }
}
