import WebSocket from 'isomorphic-ws'
import { CONFIG } from '@fivestars-pos-sdk/config'
import { 
    ILoyaltyCredentials,
    MessageAuthenticationResponse,
    MessageFailure,
    ReadyState,
    ReconnectOptions,
    WebSocketConfiguration,
    WebSocketReconnectReason,
    TransportType,
    Message,
    MessageGeneral,
    WebsocketConnectStatistics,
    WebSocketError
 } from '@fivestars-pos-sdk/types'
import { Transport } from '../transport'
import { WebSocketCommonAction } from '../../utils/enums';
import * as messengerActions from '../../actions';

// AB todo: add log from Instore, replace console.log, console..

export const LOG_PREFIX = 'WebSocketTransport';
const PING_TIMEOUT_IN_MS: number = 300 * 1000;
const PONG_TIMEOUT_IN_MS = 10000;

export class WebSocketTransport extends Transport {
  public transportType: TransportType = TransportType.WEB_SOCKET
  protected reconnectThreshold = 30
  protected resendThreshold = 10 // allow resend multiple times before triggering a reconnect
  private webSocket: WebSocket | null = null;  
  private webSocketConfiguration: WebSocketConfiguration
  private isAuthenticated = false
  private tryReconnect = true
  private pingTimeoutId: NodeJS.Timeout | null = null
  private reconnectTimeoutId: NodeJS.Timeout | null = null
  private connectedButNotOnLine = 0
  private connectRequests = 0
  private failedReconnect = 0
  private maxBufferedAmount = 0
  private pingTimeouts = 0
  private reconnectAttempts = 0
  private reconnectRequests = 0
  private reconnectUnacknowledged = 0
  private attemptingReconnect = false

  constructor() {
    super()
    console.log("WebSocketTransport::constructor")    
    this.webSocketConfiguration = this.getWebSocketConfiguration();
  }

    private getWebSocketConfiguration(): WebSocketConfiguration {
        console.log("WebSocketTransport::getWebSocketConfiguration")        
        const { HOST, MAX_RETRY_DELAY, PATH_END, PATH_START, PORT, RETRY_DELAY, SCHEME } = CONFIG.WEB_SOCKET.get();

        if (!(HOST && MAX_RETRY_DELAY && PATH_END && PATH_START && PORT && RETRY_DELAY && SCHEME)) {
            console.warn(
                `${LOG_PREFIX}::getWebSocketConfiguration`,
                `The configuration for the web socket is not fully populated. ${CONFIG.WEB_SOCKET}`
            );
        }

        console.debug(
                `${LOG_PREFIX}::getWebSocketConfiguration`,
                `Configuration for the web socket: ${CONFIG.WEB_SOCKET}`)

        console.log(`CONFIG.WEB_SOCKET: ${JSON.stringify({
            host: HOST as string,
            maxRetryDelay: Number(MAX_RETRY_DELAY),
            pathEnd: PATH_END as string,
            pathStart: PATH_START as string,
            port: Number(PORT),
            retryDelay: Number(RETRY_DELAY),
            scheme: SCHEME as string
        })}`)

        return {
            host: HOST as string,
            maxRetryDelay: Number(MAX_RETRY_DELAY),
            pathEnd: PATH_END as string,
            pathStart: PATH_START as string,
            port: Number(PORT),
            retryDelay: Number(RETRY_DELAY),
            scheme: SCHEME as string
        };
    }

    public async start(loyaltyCredentials: ILoyaltyCredentials): Promise<void> {
        console.log(`WebSocketTransport::start this.loyaltyCredentials=${this.loyaltyCredentials}, param loyaltyCredentials=${loyaltyCredentials}`)

        if (this.loyaltyCredentials.apiKey && loyaltyCredentials.apiKey !== this.loyaltyCredentials.apiKey) {
            console.log(`${LOG_PREFIX}::start`, 'Calling stop because loyalty credentials changed.');
            this.stop({ tryReconnect: false });
        }

        // calling super not at the top because super will set this.loyaltyCredentials
        // and we want to be able to compare old and new
        await super.start(loyaltyCredentials);

        if (this.isConnected() && this.isAuthenticated) {
            console.log(`${LOG_PREFIX}::start`, 'Already connected and authenticated');
        } else {
            console.log(`${LOG_PREFIX}::start`, 'Calling connect.');
            this.connect({ tryReconnect: true });
        }

        return Promise.resolve();
    }

    /*
     * Send data object via WebSocketTrace connection
     * @param {MessageGeneral} [message] - The content to be sent
     * @returns {Promise<undefined | string | Error>} indicating success or failure to send
     */
    public send(message: MessageGeneral): Promise<void> {
        console.log("WebSocketTransport::send")        

        if (!this.isAuthenticated) {
            return Promise.reject(new Error('Attempted to send message while not authenticated.'));
        }

        if (!this.isConnected()) {
            if (!this.isConnecting() && !this.reconnectTimeoutId) {
                console.info(`${LOG_PREFIX}::send`, `Calling reconnect.`);
                this.reconnect(this.webSocketConfiguration.retryDelay);
            }
            return Promise.reject(new Error('Attempted to send message while not connected.'));
        }

        return new Promise((resolve, reject) => {
            try {
                if (this.webSocket) {
                    this.webSocket.send(JSON.stringify(message));
                    this.setMaxBufferedAmount();
                    resolve();
                } else {
                    reject(new Error('Web socket object not set at time of send.'));
                }
            } catch (error) {
                reject(error);
            }
        });
    }

    public isReady(): boolean {
        console.log("WebSocketTransport::isReady")        

        return this.isAuthenticated && this.isConnected();
    }

    public stop(options: ReconnectOptions): void {
        console.log("WebSocketTransport::stop")        

        console.info(`${LOG_PREFIX}::stop`, `Called with ${JSON.stringify(options)}.`);
        this.tryReconnect = options.tryReconnect;
        this.isAuthenticated = false;

        if (this.pingTimeoutId) {
            clearTimeout(this.pingTimeoutId);
            this.pingTimeoutId = null;
        }

        if (this.reconnectTimeoutId) {
            clearTimeout(this.reconnectTimeoutId);
            this.reconnectTimeoutId = null;
        }

        if (this.webSocket && !this.isClosing() && !this.isClosed()) {
            try {
                console.info(`${LOG_PREFIX}::stop`, 'Calling close on web socket.');
                this.webSocket.close();
            } catch (error) {
                console.warn(`${LOG_PREFIX}::stop`, error);
            }
        } else {
            console.info(
                `${LOG_PREFIX}::stop`,
                `Skipping close because webSocket: ${
                    this.webSocket ? true : false
                }, isClosing: ${this.isClosing()} and isClosed: ${this.isClosed()}`
            );
        }
    }

    public terminate(): void {
        console.log("WebSocketTransport::terminate")        

        if (this.webSocket && this.isClosing()) {
            console.info(`${LOG_PREFIX}::terminate`, 'Setting the web socket to null instead of waiting for close.');
            // this.webSocket.onopen = null;
            // this.webSocket.onclose = null;
            // this.webSocket.onmessage = null;
            // this.webSocket.onerror = null;
            this.webSocket = null;
        } else {
            console.info(
                `${LOG_PREFIX}::terminate`,
                `No action taken because webSocket: ${
                    this.webSocket ? true : false
                } and isClosing: ${this.isClosing()}`
            );
        }
    }

    public incrementUnackedReconnect(): void {
        console.log("WebSocketTransport::incrementUnackedReconnect")                
        this.reconnectUnacknowledged += 1;
    }

    public incrementConnectedButNotOnLine(): void {
        console.log("WebSocketTransport::incrementConnectedButNotOnLine")                        
        this.connectedButNotOnLine += 1;
    }

    public setMaxBufferedAmount(): void {
        console.log("WebSocketTransport::setMaxBufferedAmount")                        
        if (this.webSocket && this.webSocket.bufferedAmount) {
            const BUFFERED_AMOUNT: number = this.webSocket.bufferedAmount;

            if (this.maxBufferedAmount < BUFFERED_AMOUNT) {
                this.maxBufferedAmount = BUFFERED_AMOUNT;
            }
        }
    }

    public getStats(_endTime: number): WebsocketConnectStatistics {
        console.log("WebSocketTransport::getStats ", _endTime)                                
        return {
            connectRequests: this.connectRequests,
            connectedButNotOnLine: this.connectedButNotOnLine,
            failedReconnect: this.failedReconnect,
            maxBufferedAmount: this.maxBufferedAmount,
            pingTimeouts: this.pingTimeouts,
            reconnectAttempts: this.reconnectAttempts,
            reconnectRequests: this.reconnectRequests,
            reconnectUnacknowledged: this.reconnectUnacknowledged
        };
    }

    /**
     * Reset counters
     */
    public resetStats(endTime: number): void {
        console.log("WebSocketTransport::resetStats ", endTime)                                        
        super.resetStats(endTime);
        // reset all counters
        this.connectedButNotOnLine = 0;
        this.connectRequests = 0;
        this.failedReconnect = 0;
        this.maxBufferedAmount = 0;
        this.pingTimeouts = 0;
        this.reconnectAttempts = 0;
        this.reconnectRequests = 0;
        this.reconnectUnacknowledged = 0;
    }

    private isConnecting(): boolean {
        console.log("WebSocketTransport::isConnecting")                                        

        return Boolean(this.webSocket && this.webSocket.readyState === ReadyState.CONNECTING);
    }

    public isConnected(): boolean {
        console.log("WebSocketTransport::isConnected")                                        
 
        return Boolean(this.webSocket && this.webSocket.readyState === ReadyState.OPEN);
    }

    private isClosing(): boolean {
        console.log("WebSocketTransport::isClosing")                                        

        return Boolean(this.webSocket && this.webSocket.readyState === ReadyState.CLOSING);
    }

    public isClosed(): boolean {
        console.log("WebSocketTransport::isClosed ")                                        

        return Boolean(!this.webSocket || (this.webSocket && this.webSocket.readyState === ReadyState.CLOSED));
    }

    private connect(options: ReconnectOptions): void {
        console.log("WebSocketTransport::connect")                                        

        this.tryReconnect = options.tryReconnect;

        // if we are connecting or connected then we are good
        // if we are closing then we may be in the reconnect loop
        // and we are waiting for the close to complete
        if (this.isConnecting() || this.isConnected() || this.isClosing()) {
            console.info(
                `${LOG_PREFIX}::connect`,
                `Exiting because isConnecting: ${this.isConnecting()}, isConnected: ${this.isConnected()}, isClosing: ${this.isClosing()}.`
            );
            return;
        }
        this.setupWebSocket();
        this.connectRequests += 1;
    }

    private getUrl(): string {
        console.log("WebSocketTransport::getUrl")                                                        
        const scheme = this.webSocketConfiguration.scheme;
        const host = this.webSocketConfiguration.host;
        const port = this.webSocketConfiguration.port;
        const pathStart = this.webSocketConfiguration.pathStart;
        const apiKey = this.loyaltyCredentials.apiKey;
        const pathEnd = this.webSocketConfiguration.pathEnd;

        // prettier-ignore
        // return `${scheme}://${host}:${port}${pathStart}${apiKey}${pathEnd}`;
        return "ws://ws.nerfstars.com:80/connect/apikey/47ee3d19c49a433895ac6cbf8f34778e/mpay"
    }

    private setupWebSocket(): void {
        console.log("WebSocketTransport::setupWebSocket")                                                        
        this.webSocket = new WebSocket(this.getUrl());
        this.webSocket.onopen = this.onOpenCallback;
        this.webSocket.onclose = this.onCloseCallback as (event: object) => void;
        this.webSocket.onmessage = this.onMessage as (event: object) => void;
        this.webSocket.onerror = this.onErrorCallback;
    }

    protected onOpenCallback = (event: any): void => {
        console.log("WebSocketTransport::onOpenCallback")                                                                
        this.dispatchAction(messengerActions.webSocket.connectEvent());
    }

    protected onCloseCallback = (event: Record<string, string | number>): void => {
        console.log("WebSocketTransport::onCloseCallback")                                                                        
        const CODE: number | string = event && event.code ? event.code : 'unknown';

        if (this.webSocket) {
            this.isAuthenticated = false;
            this.dispatchAction(messengerActions.webSocket.closeEvent(`Code: ${CODE}`));

            if (this.tryReconnect) {
                console.info(`${LOG_PREFIX}::onCloseCallback`, `Triggering reconnect. Code: ${CODE}`);
                this.reconnect(this.webSocketConfiguration.retryDelay);
            } else {
                console.info(`${LOG_PREFIX}::onCloseCallback`, `Not trying reconnect. Code: ${CODE}`);
            }
        } else {
            console.warn(
                `${LOG_PREFIX}::onCloseCallback`,
                `Web socket not set.  Likely after terminiate.  Code: ${CODE}`
            );
        }
    }

    protected onErrorCallback = (event: any): void => {
        console.log("WebSocketTransport::onErrorCallback")                                                                        

        this.dispatchAction(messengerActions.webSocket.errorEvent(event));
    }

    private onMessage = (event: any) => {
        console.log("WebSocketTransport::onMessage")                                                                                        
        if (!event || !event.data) {
            console.warn(`${LOG_PREFIX}::onMessage`, 'Received an invalid message event.');
            console.info(`${LOG_PREFIX}::onMessage`, event);
            return;
        }

        this.onMessageCallback(event.data);
    }

    protected filterMessage(message: Message): boolean {
        console.log("WebSocketTransport::filterMessage")                                                                                        
        if (message.action === WebSocketCommonAction.DEVICE_COUNTS) {
            // These messages are noisy and useless.
            return true;
        }

        if (message.action === WebSocketCommonAction.SUBSCRIBER_DISCONNECTED) {
            // This may be useful in the future to alert when paired device is down.
            return true;
        }

        return false;
    }

    protected handleTransportSpecificMessage(message: Message): boolean {
        console.log("WebSocketTransport::handleTransportSpecificMessage ", message)                                                                                                        
        this.setMaxBufferedAmount();

        if (message.action === WebSocketCommonAction.AUTHENTICATION_REQUEST) {
            this.messageAuthenticationRequest();
            return true;
        }
        if (message.action === WebSocketCommonAction.AUTHENTICATION_RESPONSE) {
            this.messageAuthenticationResponse(message as unknown as MessageAuthenticationResponse);
            return true;
        }
        if (message.action === WebSocketCommonAction.SUBSCRIBER_AUTHENTICATED) {
            this.messageSubscriberAuthenticated();
            return true;
        }
        if (message.action === WebSocketCommonAction.FAILURE) {
            this.messageFailure(message as MessageFailure);
            return true;
        }
        if (message.action === WebSocketCommonAction.PONG) {
            this.messagePong();
            return true;
        }

        return false;
    }

    private messageAuthenticationRequest(): void {
        console.log("WebSocketTransport::messageAuthenticationRequest")                                                                                                        
        if (!this.webSocket || !this.isConnected()) {
            console.warn(
                `${LOG_PREFIX}::messageAuthenticationRequest`,
                'Attempting to send credentials but web socket is not connected.'
            );
            return;
        }

        try {
            console.info(`${LOG_PREFIX}::messageAuthenticationRequest`, 'Sending credentials.');
            this.webSocket.send(
                JSON.stringify({
                    auth: {
                        apisecret: this.loyaltyCredentials.apiSecret,
                        business_name: this.loyaltyCredentials.softwareId
                    }
                })
            );
        } catch (error) {
            console.warn(`${LOG_PREFIX}::messageAuthenticationRequest`, error);
        }
    }

    private messageAuthenticationResponse(message: MessageAuthenticationResponse): void {
        console.log("WebSocketTransport::messageAuthenticationResponse ", message)                                                                                                        

        // AB todo: need to implement this timer from Instore
//            timeout: call(delay, WAIT_ON_AUTHENTICATION_MS)

        if (message.data.success) {
            console.info(`${LOG_PREFIX}::messageAuthenticationResponse`, 'Success');
            this.isAuthenticated = true;
            this.dispatchAction(messengerActions.webSocket.authenticationSuccessful());
            console.info(`${LOG_PREFIX}::messageAuthenticationResponse`, 'Authentication succeeded for the web socket.')
            this.ping();
        } else {
            console.info(`${LOG_PREFIX}::messageAuthenticationResponse`, 'Failure');
            this.isAuthenticated = false;
            this.dispatchAction(messengerActions.webSocket.authenticationFailure());
            this.stop({ tryReconnect: false });

            const MESSAGE = 'Failed to authenticate the web socket.';
            throw new WebSocketError(401, MESSAGE);
        }
    }

    private messageSubscriberAuthenticated(): void {
        console.log("WebSocketTransport::messageSubscriberAuthenticated")                                                                                                                        
        this.dispatchAction(messengerActions.webSocket.subscriberAuthenticated());
    }

    private messageFailure(message: MessageFailure): void {
        console.log("WebSocketTransport::messageFailure")                                                                                                                                
        console.warn(`${LOG_PREFIX}::messageFailure`, message);
        this.stop({ tryReconnect: true });
    }

    private messagePong(): void {
        console.log("WebSocketTransport::messagePong")                                                                                                                                
        
        this.setupPing(PING_TIMEOUT_IN_MS);
        this.dispatchAction(messengerActions.webSocket.pongReceived());
    }

    private setupPing(timeoutInMs = 0): void {
        console.log("WebSocketTransport::setupPing")                                                                                                                                        
        if (this.pingTimeoutId) {
            clearTimeout(this.pingTimeoutId);
            this.pingTimeoutId = null;
        }

        /*
         * If we are calling this after we are in the reconnect
         * loop, then don't send a ping again.
         * The idea being ping/pong will get setup again
         * by the reconnect.
         * Important: we do not want two timeouts running
         * at the same time as trying to track the behavior
         * is nearly impossible!
         */
        if (!this.reconnectTimeoutId) {
            this.pingTimeoutId = global.setTimeout(() => {
                this.ping();
            }, timeoutInMs);
        }
    }

     public touch(): Promise<void> {
        console.log("WebSocketTransport::touch")                                                                                                                                                         
        this.setupPing();
        return Promise.resolve();
    }

    private ping(): void {
        console.log("WebSocketTransport::ping")                                                                                                                                                        
        this.tryReconnect = true;
        if (this.webSocket && this.isConnected()) {
            try {
                this.webSocket.send(JSON.stringify({ action: WebSocketCommonAction.PING }));
            } catch (error) {
                console.warn(`${LOG_PREFIX}::ping`, error);
            }
        }

        this.pingTimeoutId = global.setTimeout(() => {
            this.dispatchAction(messengerActions.webSocket.pongTimeout());
            this.pingTimeouts += 1;

            if (!this.isAttemptingReconnect()) {
                if (!this.isConnected()) {
                    console.info(
                        `${LOG_PREFIX}::ping`,
                        `Timed out, not already attempting reconnect and not connected so calling reconnect.`
                    );
                    this.reconnect(this.webSocketConfiguration.retryDelay);
                } else {
                    console.info(
                        `${LOG_PREFIX}::ping`,
                        `Timed out so calling ping again (isAttemptingReconnect: ${this.isAttemptingReconnect()} isConnected: ${this.isConnected()}).`
                    );
                    this.ping();
                }
            } else {
                console.info(
                    `${LOG_PREFIX}::ping`,
                    'Timed out, exiting the ping timeout loop because already attempting to reconnect.'
                );
            }
        }, PONG_TIMEOUT_IN_MS);
    }

    public triggerReconnect(): void {
        console.log("WebSocketTransport::triggerReconnect")                                                                                                                                                                

        this.dispatchAction(messengerActions.webSocket.reconnectRequest(WebSocketReconnectReason.UNACKED_MESSAGE));
    }

    /**
     * Tracks the number of times we call reconnect
     */
    private reconnect(retryDelayInSeconds: number): void {
        console.log("WebSocketTransport::reconnect ", retryDelayInSeconds)                                                                                                                                                                

        console.info(
            `${LOG_PREFIX}::reconnect`,
            `Calling attemptReconnect (${this.reconnectRequests} since heartbeat).`
        );
        this.reconnectRequests += 1;
        this.attemptingReconnect = true;
        this.attemptReconnect(retryDelayInSeconds);
    }

    /**
     * Performs the actual reconnect logic, with a decaying backoff
     *
     * Once maximum delay is reached, emits FAILED_TO_RECONNECT websocket error event.
     * Should not be called directly except through reconnect function
     */
    private attemptReconnect(retryDelayInSeconds: number): void {
        console.log("WebSocketTransport::attemptReconnect ", retryDelayInSeconds)                                                                                                                                                                        
        this.setMaxBufferedAmount();
        // Clear any pending timeouts before proceeding.
        if (this.reconnectTimeoutId) {
            clearTimeout(this.reconnectTimeoutId);
            this.reconnectTimeoutId = null;
        }

        // Once we are authenticated we have completed the connection process.
        // The first step is to connect to the web socket server, then we get
        // a "ws.ack" message which triggers us to send the credentials, and
        // finally we receive a "ws.authAck" which confirms we are authenticated.
        if (this.isAuthenticated) {
            console.info(`${LOG_PREFIX}::attemptReconnect`, 'Authenticated so exiting the reconnect loop.');
            this.attemptingReconnect = false;
            return;
        }

        const WAIT_ON_CLOSE_IN_MS = 1000;

        // If we are not in a closed state that means we are either closing, connecting, or connected.
        // We want to keep checking until we are authenticated or if we are closed then we try to
        // reconnect again.
        if (!this.isClosed()) {
            this.reconnectTimeoutId = global.setTimeout(() => {
                this.attemptReconnect(retryDelayInSeconds);
            }, WAIT_ON_CLOSE_IN_MS);
        } else if (retryDelayInSeconds <= this.webSocketConfiguration.maxRetryDelay) {
            console.info(
                `${LOG_PREFIX}::attemptReconnect`,
                `Setting a timer to attempt a reconnect again in ${retryDelayInSeconds * 2} seconds.`
            );
            this.reconnectTimeoutId = global.setTimeout(() => {
                this.attemptReconnect(retryDelayInSeconds * 2);
            }, retryDelayInSeconds * 1000);

            // We call connect with tryReconnect set to false because we will
            // call reconnect again as part of the reconnect timeout loop.
            console.info(
                `${LOG_PREFIX}::attemptReconnect`,
                `Calling connect (${this.reconnectAttempts} since heartbeat).`
            );
            this.reconnectAttempts += 1;
            this.connect({ tryReconnect: false });
        } else {
            console.info(
                `${LOG_PREFIX}::attemptReconnect`,
                `Failed to reconnect (${this.failedReconnect} since heartbeat).`
            );
            this.attemptingReconnect = false;
            this.failedReconnect += 1;
            this.dispatchAction(messengerActions.webSocket.failedToReconnect());
        }
    }

    public isAttemptingReconnect(): boolean {
        console.log("WebSocketTransport::isAttemptingReconnect ")                                                                                                                                                                        
        return this.attemptingReconnect;
    }
}
