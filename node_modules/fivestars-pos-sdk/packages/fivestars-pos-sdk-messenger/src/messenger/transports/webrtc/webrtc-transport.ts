import { EventEmitter } from 'events'
import simplePeer from 'simple-peer'
const wrtc = require('wrtc')
import { 
    ILoyaltyCredentials,
    TransportType,
    MessageGeneral,
    Message,
    WebRtcAction,
    WebRtcStats,
    WebRtcErrorStats
,} from '@fivestars-pos-sdk/types'
import { Transport } from '../transport'
import { constructMessageGeneral } from '../../utils';
import * as messengerActions from '../../actions';

export const LOG_PREFIX = 'WebRtcTransport';
const isInitiator = (): boolean => { return true }
// AB todo: implement CONFIG like Instore then uncomment line below
//const isInitiator = (): boolean => CONFIG.PRODUCT !== Product.CPAY;

export class WebRtcTransport extends Transport {
    public transportType: TransportType = TransportType.WEB_RTC
    protected reconnectThreshold = 6
    protected resendThreshold = 3
    private peer: simplePeer.Instance | null = null
    private isDataChannelReady = false
    private stats: WebRtcErrorStats = {
        onError: 0,
        onErrorIceConnectionFailure: 0
    }
    private static ERR_CODE_ICE_CONNECTION_FAILURE = 'ERR_ICE_CONNECTION_FAILURE'
    private static ERROR_RECONNECT_THRESHOLD = 5

    constructor() {
        super()
        console.debug("WebRtcTransport::constructor")
        this.peer = null
    }

    public start(loyaltyCredentials: ILoyaltyCredentials): Promise<void> {
        console.log("WebRtcTransport::start")

        console.log("WebRtcTransport::start", loyaltyCredentials)
        // create instance in start instead of constructor
        // initiator will try to initiate immediately, so wait until the application
        // is ready to go before even trying
        this.peer = this.createPeer(isInitiator())
        return Promise.resolve()
    }

    private createPeer(initiator: boolean): simplePeer.Instance {
        console.debug("WebRtcTransport::createPeer")

        const PEER = (typeof window === 'undefined') 
            ? new simplePeer({ initiator, trickle: false, wrtc: wrtc })
            : new simplePeer({ initiator, trickle: false })

        PEER.on('signal', this.onSignal)
        PEER.on('connect', this.onConnect)
        PEER.on('data', this.onMessageCallback)
        PEER.on('close', this.onClose)
        PEER.on('error', this.onError)

        return PEER
    }

    public isReady(): boolean {
        console.debug("WebRtcTransport::isReady")
        return this.isDataChannelReady
    }

    /**
     * Used in connection saga to determine if we should be retrying the connection
     * Allowing a small number of errors before abandoning WebRTC as a transport because
     * there are some cases where normal, healthy, WebRTC using merchants hit onError then recover quickly
     */
    public allowReconnect(): boolean {
        console.debug("WebRtcTransport::allowReconnect")
        return this.stats.onError < WebRtcTransport.ERROR_RECONNECT_THRESHOLD
    }

    public async send(messageGeneral: MessageGeneral): Promise<void> {
        console.debug("WebRtcTransport::send")
        if (!this.isDataChannelReady) {
            throw new Error('WebRTC data channel not ready')
        }

        if (!this.peer) {
            throw new Error('Peer object is null')
        }
        try {
            this.peer.send(JSON.stringify(messageGeneral))
        } catch (error) {
            console.info(`${LOG_PREFIX}::send::error`, JSON.stringify(error))
            throw error
        }
    }

    protected handleTransportSpecificMessage(message: Message): boolean {
        console.debug("WebRtcTransport::handleTransportSpecificMessage ", message)
        switch (message.action) {
            case WebRtcAction.PING:
                this.dispatchAction(messengerActions.webRtc.pingReceived(message.uuid));
                this.pingPongStats.pingReceived += 1
                return true;
            case WebRtcAction.PONG:
                this.trackPongReceived(message);
                this.dispatchAction(messengerActions.webRtc.pongReceived());
                return true
            default:
                return false
        }
    }


    /**
     * Temporary: for gather web rtc usability data
     */
    public async sendPing(): Promise<void> {
        console.debug("WebRtcTransport::sendPing")
        const MESSAGE: MessageGeneral = constructMessageGeneral({
            action: WebRtcAction.PING
        })
        try {
            await this.send(MESSAGE)
            this.trackPingSent(MESSAGE)
            this.dispatchAction(messengerActions.webRtc.pingSent());
        } catch {
            this.pingPongStats.pingSentFailed += 1
        }
    }

   /**
     * Temporary: for gather web rtc usability data
     */
    public async sendPong(uuid: string): Promise<void> {
        console.debug("WebRtcTransport::sendPong")
        const MESSAGE: MessageGeneral = constructMessageGeneral({
            action: WebRtcAction.PONG,
            uuid
        })

        try {
            await this.send(MESSAGE);
            this.pingPongStats.pongSent += 1;
        } catch {
            this.pingPongStats.pongSentFailed += 1;
        }
    }

    /**
     * Set remote description. Call this when receiving an offer or answer
     *
     * For more details on what this means see [RTCPeerConnection docs](https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/setRemoteDescription)
     *
     * @param signalData
     */
    public setRemoteDescription(signalData: simplePeer.SignalData): void {
        console.debug("WebRtcTransport::setRemoteDescription")
        if (this.peer) {
            this.peer.signal(signalData);
        }
    }

    /**
     * Destroy current instance
     */
    public stop(): void {
        console.debug("WebRtcTransport::stop")
        if (this.peer) {
            this.peer.destroy();
        }
        this.isDataChannelReady = false;
        this.peer = null;
        this.dispatchAction(messengerActions.webRtc.stopped());
    }

    /**
     * Callback for when this peer's signal data is ready.
     * Use this data to create offer/answer
     *
     * @param data
     */
    public onSignal = (data: simplePeer.SignalData): void => {
       console.debug("WebRtcTransport::onSignal", data)
       this.dispatchAction(messengerActions.webRtc.signalData(data))
    }

    /**
     * Callback fired when data channel is ready to use
     * Technically, calling send with simple-peer before channel is ready, messages
     * are buffered. To make life easier, just don't send messages unless the channel is ready
     */
    public onConnect = (): void => {
       console.debug("WebRtcTransport::onConnect")
       this.isDataChannelReady = true
       // AB todo: need to emit this
       this.dispatchAction(messengerActions.webRtc.ready())
    }

    private onClose(error: Error): void {
        console.debug("WebRtcTransport::onClose", error)        
        console.info(`${LOG_PREFIX}::onClose`, JSON.stringify(error))
        this.stop()
    }

    private onError(error: Error): void {
        console.debug("WebRtcTransport::onError", error)                        
        console.info(`${LOG_PREFIX}::onError`, JSON.stringify(error))
        this.stats.onError += 1;

        // @ts-ignore
        // code does not exist on Error type, this code property was found by looking through logs
        if (error.code === WebRtcTransport.ERR_CODE_ICE_CONNECTION_FAILURE) {
            this.stats.onErrorIceConnectionFailure += 1;
        }
    }

    public triggerReconnect(): void {
        console.debug("WebRtcTransport::triggerReconnect")
        this.dispatchAction(messengerActions.webRtc.reconnectRequest());
    }
    /* Stats */

    public getStats(endTime: number): WebRtcStats {
        console.debug("WebRtcTransport::getStats")
        return {
            errorStats: { ...this.stats },
            pingPongDurationStats: { ...this.getPingPongDurationStats(endTime) },
            pingPongStats: { ...this.pingPongStats }
        }
    }

    public resetStats(endTime: number): void {
        console.debug("WebRtcTransport::resetStats")
        super.resetStats(endTime);
        this.stats = {
            onError: 0,
            onErrorIceConnectionFailure: 0
        }
    }

    public touch(): Promise<void> {
        console.debug("WebRtcTransport::touch")
        return this.sendPing();
    }
}