import { AES, DecryptedMessage, enc } from 'crypto-js';
import { gzip, ungzip } from 'pako';
import { Message, MessageGeneral, ILoyaltyCredentials } from '@fivestars-pos-sdk/types'
//import { log } from '@instore/utils/log';
// AB todo: implement above log

import { Transport } from './transport';

export class EncryptedTransport<MessageExtra = Record<string, unknown>> extends Transport<MessageExtra> {
    private decryptionIgnore: Set<string> = new Set();

    constructor() {
        super();
    }

    public parse(message: string): Message | null {
        try {
            return this.decrypt(message);
        } catch (error) {
            if (this.decryptionIgnore.has(message)) {
                // discard this message since we've already seen it, and had trouble decrypting it
                return null;
            }
            console.info(`${this.transportType}::parse error decrypting and parsing message`, error);
        }

        /**
         * To prevent decryption errors from dominating the logs; store the raw message that had a decryption error
         * and discard messages that come in that match
         */
        this.decryptionIgnore.add(message);

        return null;
    }

    /**
     * Encrypt message using our paired device's api secret
     * @param message
     */
    protected encrypt(message: MessageGeneral): string {
        // If paired device is not set, use OUR api-secret for encryption.
        // NOTE: This should not happen, as encrypted transports are not
        // enabled to send paired messages unless they are paired.
        const ENCRYPTION_KEY: string = this.pairedDevice
            ? this.pairedDevice.apiSecret
            : this.loyaltyCredentials.apiSecret;
        const COMPRESSED_JSON_STRING: string = gzip(JSON.stringify(message), { to: 'string' });
        return AES.encrypt(COMPRESSED_JSON_STRING, ENCRYPTION_KEY).toString();
    }

    /**
     * Decrypt incoming messages using our api-secret
     * If we are unable to decrypt and parse the message, it should not be trusted
     */
    protected decrypt(cipherText: string): Message {
        const BYTES: DecryptedMessage = AES.decrypt(cipherText, this.loyaltyCredentials.apiSecret);
        return JSON.parse(ungzip(BYTES.toString(enc.Utf8), { to: 'string' }));
    }
}
