// import dexie from 'dexie';

// import { AnalyticsTrackerEventName } from '../utils/enums';
// import { stringifyError } from '@instore/utils/stringifyError';

// // By defining the interface of table records,
// // you get better type safety and code completion
// export interface CompletedEvent {
//     id?: number; // Primary key. Optional (autoincremented)
//     event: string | object;
// }

// export interface InProgressEvent {
//     eventName: AnalyticsTrackerEventName | string;
//     event: string;
// }

// export class AnalyticsEventsDatabase extends dexie {
//     private completedEvents: dexie.Table<CompletedEvent, number>;

//     constructor() {
//         super('AnalyticsEventsDatabase');

//         // This version is indicating the version of the db implementation
//         // if in the future we wanted to change the db and store different
//         // things, we'd increment the version
//         // Note: IndexedDB does not support database downgrades, but our app does. Thus, we can never
//         // upgrade the version of an existing database safely.
//         this.version(1).stores({
//             completedEvents: '++id'
//         });

//         // The following lines are needed for it to work across typescipt using babel-preset-typescript:
//         this.completedEvents = this.table('completedEvents');
//     }

//     /**
//      * Returns the CompletedEvent with the lowest id in the db, or undefined if the db is empty
//      */
//     *getNextEvent() {
//         return yield this.completedEvents.limit(1).first();
//     }

//     /**
//      * Stores the event as a CompletedEvent in the db
//      * The id is autoincremented, so the event effectively goes to the back of the queue
//      */
//     *storeCompletedEvent(event: any) {
//         // we use our custom strinifyError here that will JSON.stringify non-errors and do some intelligent parsing for error objects
//         const COMPLETED_EVENT: CompletedEvent = { event: stringifyError(event) };
//         yield this.completedEvents.add(COMPLETED_EVENT);
//     }

//     *deleteCompletedEvent(id: number) {
//         yield this.completedEvents.delete(id);
//     }
// }

// export class AnalyticsInProgressEventDatabase extends dexie {
//     private inProgressEvents: dexie.Table<InProgressEvent, AnalyticsTrackerEventName | string>;

//     constructor() {
//         super('AnalyticsInProgressEventDatabase');

//         this.version(1).stores({
//             inProgressEvents: 'eventName'
//         });

//         // The following lines are needed for it to work across typescipt using babel-preset-typescript:
//         this.inProgressEvents = this.table('inProgressEvents');
//     }

//     /**
//      * Stores the event as an InProgressEvent in the db
//      * If there is an existing entry with the same name, it will get overwritten
//      */
//     *storeInProgressEvent(eventName: AnalyticsTrackerEventName | string, event: any) {
//         // we use our custom strinifyError here that will JSON.stringify non-errors and do some intelligent parsing for error objects
//         const inProgressEvent: InProgressEvent = { event: stringifyError(event), eventName };
//         yield this.inProgressEvents.put(inProgressEvent);
//     }

//     *deleteInProgressEvent(eventName: AnalyticsTrackerEventName | string) {
//         yield this.inProgressEvents.delete(eventName);
//     }

//     /**
//      * Returns an array of all the in progress events
//      * We don't expect this to ever be very large, since events get deleted once
//      * they get closed out
//      */
//     *getAllInProgressEvents() {
//         return yield this.inProgressEvents.toArray();
//     }

//     /**
//      * Deletes all in progress events
//      */
//     *deleteAllInProgressEvents() {
//         yield this.inProgressEvents.clear();
//     }
// }

// export const analyticsInProgressEventDatabase = new AnalyticsInProgressEventDatabase();
// export const analyticsEventDatabase = new AnalyticsEventsDatabase();
