// import * as moment from 'moment';

// import { getPathname, Pathname } from '@app/components/routes';
// import { AnalyticsTrackerEventName, AnalyticsTrackerEventProperty } from '@instore/utils/enums';
// import { log } from '@instore/utils/log';
// import { SkewAdjustedTime } from '@instore/utils/skewAdjustedTime';

// import { analyticsTracker } from './analyticsTracker';

// export const pageTransition = {
//     _closePreviousEvents(startPathname: Pathname): void {
//         const PAGE_TRANSITION_EVENT = analyticsTracker.getTimedEvent(AnalyticsTrackerEventName.PAGE_TRANSITION);

//         if (!PAGE_TRANSITION_EVENT) {
//             return;
//         }

//         // If we find a timed event then we need to close it out before we start the new timed event.
//         const PAGE_TRANSITION_START_STATE: Pathname =
//             PAGE_TRANSITION_EVENT.eventProperties[AnalyticsTrackerEventProperty.START_STATE];
//         const PAGE_TRANSITION_END_STATE: Pathname =
//             PAGE_TRANSITION_EVENT.eventProperties[AnalyticsTrackerEventProperty.END_STATE];

//         if (PAGE_TRANSITION_START_STATE === startPathname) {
//             throw new Error(
//                 `Trying to track a page transition for ${startPathname} while trying to start a new page transition for the same page.`
//             );
//         }

//         if (PAGE_TRANSITION_END_STATE !== startPathname) {
//             throw new Error(
//                 `Trying to close out an existing page transition but the end page ${PAGE_TRANSITION_END_STATE} does not match the new start page ${startPathname}.`
//             );
//         }

//         analyticsTracker.track(AnalyticsTrackerEventName.PAGE_TRANSITION, PAGE_TRANSITION_EVENT.eventProperties);
//         const PAGE_DURATION_EVENT = analyticsTracker.getTimedEvent(AnalyticsTrackerEventName.PAGE_DURATION);

//         if (!PAGE_DURATION_EVENT) {
//             throw new Error(`Missing the page duration event for ${startPathname}.`);
//         }

//         const PAGE_DURATION_SCREEN = PAGE_DURATION_EVENT.eventProperties[AnalyticsTrackerEventProperty.SCREEN];

//         if (PAGE_DURATION_SCREEN !== PAGE_TRANSITION_END_STATE) {
//             throw new Error(
//                 `The page duration should be for ${PAGE_TRANSITION_END_STATE} but is actually for ${PAGE_DURATION_SCREEN}.`
//             );
//         }

//         analyticsTracker.track(AnalyticsTrackerEventName.PAGE_DURATION);
//     },

//     start(startPathString: string, endPathString: string): void {
//         try {
//             const endPathname: Pathname = getPathname(endPathString);
//             const startPathname: Pathname = getPathname(startPathString);

//             if (startPathname === Pathname.Invalid) {
//                 throw new Error(`Invalid start pathname: ${startPathString}`);
//             }

//             if (endPathname === Pathname.Invalid) {
//                 throw new Error(`Invalid end pathname: ${endPathString}`);
//             }

//             pageTransition._closePreviousEvents(startPathname);

//             const eventProperties = {
//                 [AnalyticsTrackerEventProperty.START_STATE]: startPathname,
//                 [AnalyticsTrackerEventProperty.END_STATE]: endPathname
//             };
//             analyticsTracker.startTimedEvent(AnalyticsTrackerEventName.PAGE_TRANSITION, eventProperties);
//         } catch (error) {
//             console.warn(`pageTransition::start`, error);
//         }
//     },

//     track(pathString: string): void {
//         try {
//             const pathname: Pathname = getPathname(pathString);

//             if (pathname === Pathname.Invalid) {
//                 throw new Error(`Invalid pathname: ${pathString}`);
//             }

//             const pageTransitionEvent = analyticsTracker.getTimedEvent(AnalyticsTrackerEventName.PAGE_TRANSITION);

//             // We should have a page transition event already because it is set by the call to the start method.
//             // The only time we don't have a page transition is at app startup in which case we will hit track
//             // when we render the splash page.  In those cases we ignore the track event.
//             // We only want to update the endTime if it is not set already.  If we have already called track
//             // then the page state is changing but we don't want to change the endTime for the page transition.
//             if (!pageTransitionEvent) {
//                 return;
//             }

//             if (pageTransitionEvent.endTime !== null) {
//                 return;
//             }

//             if (pageTransitionEvent.eventProperties[AnalyticsTrackerEventProperty.END_STATE] !== pathname) {
//                 throw new Error(
//                     `Event being tracked is for ${
//                         pageTransitionEvent.eventProperties[AnalyticsTrackerEventProperty.END_STATE]
//                     } but the request is for ${pathname}.`
//                 );
//             }

//             pageTransitionEvent.endTime = moment(SkewAdjustedTime.now());
//             const PAGE_DURATION_EVENT = analyticsTracker.getTimedEvent(AnalyticsTrackerEventName.PAGE_DURATION);

//             if (PAGE_DURATION_EVENT) {
//                 const PAGE_DURATION_SCREEN =
//                     PAGE_DURATION_EVENT.eventProperties[AnalyticsTrackerEventProperty.SCREEN];
//                 throw new Error(
//                     `We should be initializing the page duration for ${pathname} but there is already a page duration event for ${PAGE_DURATION_SCREEN}.`
//                 );
//             }

//             analyticsTracker.startTimedEvent(AnalyticsTrackerEventName.PAGE_DURATION, {
//                 [AnalyticsTrackerEventProperty.SCREEN]: pathname
//             });
//         } catch (error) {
//             console.warn(`pageTransition::track`, error);
//         }
//     }
// };
