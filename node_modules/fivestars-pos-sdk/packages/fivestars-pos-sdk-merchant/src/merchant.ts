
import { Core } from "@fivestars-pos-sdk/fivestars-pos-sdk-core"
import { Transactions } from "@fivestars-pos-sdk/fivestars-pos-sdk-transaction"
import { Money } from '@fivestars-pos-sdk/fivestars-pos-sdk-utils'
export const LOG_PREFIX = 'Merchant';

export class Merchant {
    private core: Core

    constructor() {
        this.core = new Core()
        console.info(`${LOG_PREFIX}::constructor`);
    }

    public startNewPayment(payment: StartPaymentPayload) {
        if (Transactions.isTransactionInProgress && 
            !Transactions.isTransactionCompleted && 
            !Transactions.isEarlyCheckin) {
            console.info(
                'host::payment::startNewPayment',
                'startNewPayment called while in a transaction, aborting transaction to get in consistent state'
            );
            yield put(transactionActions.cancel('home'))
            return
        }

        if (payment.value === null) {
            _handleBadPaymentValue(payment)
            return
        }

//        _logPayment(payment.type, payment.value);

        const PAYMENT_TYPE: PaymentTypes =
            payment.type === StartPaymentEventName.CREDIT ? PaymentTypes.CARD : PaymentTypes.CASH;
        const TRANSACTION_TOTAL_UID: string | null = payment.transactionTotalUid ? payment.transactionTotalUid : null;

        // Session

        const INITIATE_PAYMENT = Transactions.initiatePayment({
            amount: new Money(payment.value),
            paymentType: PAYMENT_TYPE,
            transactionTotalUid: TRANSACTION_TOTAL_UID,
            options: {
                showRewards: payment.options.showRewards,
                cashEnabled: _.has(payment.options, 'cashEnabled')
                    ? payment.options.cashEnabled
                    : DEFAULT_TRANSACTION_OPTIONS.cashEnabled
            }
        })

        // startPaymentFlow(INITIATE_PAYMENT)
    }


    public startNewRefund(refund: StartRefundPayload): void {
        if (Transactions.isTransactionInProgress && !Transactions.isTransactionCompleted && !Transactions.isEarlyCheckin) {
            console.info(
                'host::refund::startNewRefund',
                'startNewPayment called while in a transaction, aborting transaction to get in consistent state'
            )
            return
        }

        if (refund.value === null) {
            this._handleBadRefundValue(refund)
            return
        }

//        _logRefund(refund.value);
        const TRANSACTION_TOTAL_UID: string | null = refund.transactionTotalUid ? refund.transactionTotalUid : null;

        // Session

        const INITIATE_REFUND = Transactions.initiateRefund({
            amount: refund.value,
            transactionTotalUid: TRANSACTION_TOTAL_UID,
            isManualTransaction: refund.isManualTransaction
        })

        // startRefundFlow(INITIATE_REFUND)      
    };

    public abortPayment(): void {
    }

    public abortRefund(): void {
    }

    public cancel() {
       console.info(`${LOG_PREFIX}::cancel`);
       Transactions.abortTransaction()
    }

    private _handleBadRefundValue(refund: StartRefundPayload) {
        log.info('host::refund::startNewRefund', 'Called with null value');

        const FAILED_OCR_PAYLOAD: FailedOcrPayload = {
            isRefund: true,
            transactionTotalUid: refund.transactionTotalUid ? refund.transactionTotalUid : null
        };

        Transactions.failedOcrPayload(FAILED_OCR_PAYLOAD)
    }

    private _handleBadPaymentValue(payment: StartPaymentPayload) {
        log.info('host::payment::startNewPayment', 'Called with null value');

        const FAILED_OCR_PAYLOAD: FailedOcrPayload = {
            isRefund: false,
            options: {
                showRewards: payment.options.showRewards
            },
            transactionTotalUid: payment.transactionTotalUid ? payment.transactionTotalUid : null,
            type: payment.type
        };

        Transactions.failedOcrPayload(FAILED_OCR_PAYLOAD));
    }
}