"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Pairing = exports.LOG_PREFIX = void 0;
var fivestars_pos_sdk_core_1 = require("@fivestars-pos-sdk/fivestars-pos-sdk-core");
var fivestars_pos_sdk_storage_1 = require("@fivestars-pos-sdk/fivestars-pos-sdk-storage");
var types_1 = require("@fivestars-pos-sdk/types");
var customerDeviceColor_1 = require("../utils/customerDeviceColor");
var skewAdjustedTime_1 = require("../utils/skewAdjustedTime");
var packedApiKey_1 = require("../utils/packedApiKey");
exports.LOG_PREFIX = 'Pairing';
var Pairing = /** @class */ (function () {
    function Pairing() {
        var _this = this;
        this.start = function (loyaltyCredentials) {
            var _a;
            console.info(exports.LOG_PREFIX + "::start");
            (_a = _this.core) === null || _a === void 0 ? void 0 : _a.start(loyaltyCredentials);
        };
        this.deletePairedDevice = function () {
            console.info(exports.LOG_PREFIX + "::deletePairedDevice ");
            fivestars_pos_sdk_storage_1.PairingModel.pairedDevice = null;
        };
        /**
            Function: processDeviceMapping
    
            Paramaters:
                apiKey:
                apiSecret:
                bluetoothMacAddress:
                deviceDescription:
                hardwareId:
                udpPort:
    
            Description: called when @fivestars-pos-sdk-messenger receives 'ws.device_mapping' websocket message
        */
        this.onDeviceMapping = function (event) {
            console.info(exports.LOG_PREFIX + "::onDeviceMapping received 'device_mapping'", event);
            var message = JSON.parse(event.data);
            var PAIRED_DEVICE = _this.getPairedDevice();
            // Exit if not paired because there is nothing to update
            if (!PAIRED_DEVICE) {
                return;
            }
            // If the hardware identifier is set then verify paired device using the hardware identifier
            if (PAIRED_DEVICE.hardwareId &&
                message.hardwareId &&
                PAIRED_DEVICE.hardwareId !== message.hardwareId) {
                return;
            }
            // If the hardware identifier is not set then use the device description to verify paired device
            if ((!PAIRED_DEVICE.hardwareId || !message.hardwareId) &&
                PAIRED_DEVICE.deviceDescription !== message.deviceDescription) {
                return;
            }
            /**
            * Check if something about our paired device
            * has changed which will affect communication.
            * Use pairing action to update the paired device in redux, and trigger reconnect for messenger transports
            */
            if (message.apiKey !== PAIRED_DEVICE.apiKey ||
                message.apiSecret !== PAIRED_DEVICE.apiSecret ||
                message.bluetoothMacAddress !== PAIRED_DEVICE.bluetoothMacAddress ||
                message.udpPort !== PAIRED_DEVICE.udpPort) {
                _this.pair({
                    apiKey: message.apiKey,
                    apiSecret: message.apiSecret,
                    bluetoothMacAddress: message.bluetoothMacAddress,
                    deviceDescription: PAIRED_DEVICE.deviceDescription,
                    hardwareId: PAIRED_DEVICE.hardwareId,
                    udpPort: message.udpPort
                });
            }
        };
        /**
            Function: processErroneousPairing
    
            Parameters:
                erroneousDeviceApiKey: string,
                pairedDeviceApiKey: string)
    
            Description:
            This is a special case action for clearing out an erroneous pairing relationship
            which doesn't have the side-effects of "unpair"
        */
        this.onErroneousPairing = function (event) {
            console.info(exports.LOG_PREFIX + "::onErroneousPairing received 'erroneous_pairing'", event);
            var message = JSON.parse(event.data);
            var LOYALTY_CREDENTIALS = fivestars_pos_sdk_storage_1.AuthModel.loyaltyCredentials;
            var PAIRED_DEVICE = _this.getPairedDevice();
            // If this message was not for this device, or this device is not paired, or
            // it is not from our paired device then we ignore the message
            if (message.erroneousDeviceApiKey !== LOYALTY_CREDENTIALS.apiKey ||
                !PAIRED_DEVICE ||
                message.pairedDeviceApiKey !== PAIRED_DEVICE.apiKey) {
                return;
            }
            //        console.warn(`${LOG_PREFIX}::processErroneousPairing`, `Clearing pairing to ${PAIRED_DEVICE.apiKey}`);
            //        messengerActions.clearPairedMessageQueue() // AB todo: implement this queue, grab from instore
            var NOTIFY_PAIRED_DEVICE = false;
            _this.unPair(NOTIFY_PAIRED_DEVICE);
        };
        this.onDeviceInfoUpdate = function (event) {
            console.info(exports.LOG_PREFIX + "::onDeviceInfoUpdate received 'cts_info'", event);
            //        const message: any = JSON.parse(event);
            //        console.info(`${LOG_PREFIX}::onDeviceInfoUpdate message after JSON.parse `, message)
            fivestars_pos_sdk_storage_1.PairingModel.knownDevices.push({
                lastUpdateReceived: skewAdjustedTime_1.SkewAdjustedTime.moment(),
                apiKey: event.apikey,
                apiSecret: null,
                bluetoothMacAddress: null,
                udpPort: null,
                color: event.color,
                deviceDescription: event.description,
                pairedDevice: event.pairedDevice,
                hardwareId: event.pairedDeviceHardwareId
            });
            console.info(exports.LOG_PREFIX + "::onDeviceInfoUpdate PairingModel.knownDevices ", fivestars_pos_sdk_storage_1.PairingModel.knownDevices);
        };
        this.sendPairedMessage = function (messageDetails, options) { return __awaiter(_this, void 0, void 0, function () {
            var UUID;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.core.sendPaired(messageDetails, options)];
                    case 1:
                        UUID = _a.sent();
                        if (!UUID) {
                            console.info(exports.LOG_PREFIX + "::sendPairedMessage", "Failed to send message");
                            console.info(exports.LOG_PREFIX + "::sendPairedMessage", messageDetails);
                        }
                        return [2 /*return*/, UUID];
                }
            });
        }); };
        this.constructPairedMessageDetails = function (messageData, messageType) {
            console.log('Pairing::constructPairedMessageDetails', messageData, messageType);
            console.log('Pairing::constructPairedMessageDetails this.getPairedDevice()', _this.getPairedDevice());
            var PAIRED_DEVICE = _this.getPairedDevice();
            return {
                destination: PAIRED_DEVICE ? packedApiKey_1.getPackedApiKey(PAIRED_DEVICE.apiKey) : null,
                messageData: messageData,
                messageType: messageType,
                source: packedApiKey_1.getPackedApiKey(fivestars_pos_sdk_storage_1.AuthModel.loyaltyCredentials.apiKey),
                //            webappVersion: CONFIG.VERSION.APP_VERSION
                webappVersion: "420" // AB todo: use from config eventually
            };
        };
        this.sendSubscriberAuthenticated = function () {
            console.log('Pairing::sendSubscriberAuthenticated');
            var MESSAGE_DATA = {};
            var MESSAGE_DETAILS = _this.constructPairedMessageDetails(MESSAGE_DATA, types_1.WebSocketCommonAction.SUBSCRIBER_AUTHENTICATED);
            console.log('Pairing::sendSubscriberAuthenticated MESSAGE_DETAILS: ', MESSAGE_DETAILS);
            if (MESSAGE_DETAILS.destination) {
                _this.sendPairedMessage(MESSAGE_DETAILS, {
                    skipAcknowledgment: true,
                    uuid: null
                });
            }
        };
        this.core = new fivestars_pos_sdk_core_1.Core();
        this.core.on('device_mapping', this.onDeviceMapping);
        this.core.on('cts_info', this.onDeviceInfoUpdate);
        this.core.on('WEB_SOCKET_AUTHENTICATION_SUCCESSFUL', this.sendSubscriberAuthenticated);
        // this.core.on('WEB_SOCKET_AUTHENTICATION_SUCCESSFUL', (event: WebSocket.MessageEvent) => {
        //     console.log('in pairing::WEB_SOCKET_AUTHENTICATION_SUCCESSFUL')
        // })
        console.info(exports.LOG_PREFIX + "::constructor");
    }
    Pairing.prototype.pair = function (pairedDevice) {
        console.info(exports.LOG_PREFIX + "::start", pairedDevice);
        fivestars_pos_sdk_storage_1.PairingModel.pairedDevice = pairedDevice;
        this.core.setPairedDevice(pairedDevice);
        return Promise.resolve(true);
    };
    Pairing.prototype.unPair = function (notifyPairedDevice) {
        if (notifyPairedDevice === void 0) { notifyPairedDevice = true; }
        console.info(exports.LOG_PREFIX + "::start", notifyPairedDevice);
        fivestars_pos_sdk_storage_1.PairingModel.pairedDevice = null;
        this.core.setPairedDevice(null);
        return Promise.resolve(true);
    };
    Pairing.prototype.getInPairingMode = function () {
        console.info(exports.LOG_PREFIX + "::getInPairingMode ", fivestars_pos_sdk_storage_1.PairingModel.inPairingMode);
        return Promise.resolve(fivestars_pos_sdk_storage_1.PairingModel.inPairingMode);
    };
    Pairing.prototype.getPairedDevice = function () {
        console.info(exports.LOG_PREFIX + "::getPairedDevice ", fivestars_pos_sdk_storage_1.PairingModel.pairedDevice);
        return fivestars_pos_sdk_storage_1.PairingModel.pairedDevice;
    };
    Pairing.prototype.isPairingConfigured = function () {
        console.info(exports.LOG_PREFIX + "::isPairingConfigured ", fivestars_pos_sdk_storage_1.PairingModel.pairedDevice !== null);
        return Promise.resolve(fivestars_pos_sdk_storage_1.PairingModel.pairedDevice !== null);
    };
    Pairing.prototype.getDeviceDescription = function () {
        console.info(exports.LOG_PREFIX + "::getDeviceDescription ", fivestars_pos_sdk_storage_1.PairingModel.deviceDescription);
        return Promise.resolve(fivestars_pos_sdk_storage_1.PairingModel.deviceDescription);
    };
    //public getKnownDevices(): Promise<KnownDevice[]> {
    Pairing.prototype.getKnownDevices = function () {
        console.info(exports.LOG_PREFIX + "::getKnownDevices ", fivestars_pos_sdk_storage_1.PairingModel.knownDevices);
        return fivestars_pos_sdk_storage_1.PairingModel.knownDevices;
    };
    Pairing.prototype.setKnownDevices = function (knownDevices) {
        console.info(exports.LOG_PREFIX + "::setKnownDevices ", knownDevices);
        fivestars_pos_sdk_storage_1.PairingModel.knownDevices = knownDevices;
        return Promise.resolve(fivestars_pos_sdk_storage_1.PairingModel.knownDevices);
    };
    /**
    * Get known devices -- minus the known device that corresponds to our paired apikey
    */
    Pairing.prototype.getOtherKnownDevices = function () {
        // AB todo: look to remove line below before PROD, fix any issue
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment     
        // @ts-ignore
        var PAIRED_DEVCE_API_KEY = fivestars_pos_sdk_storage_1.PairingModel.pairedDevice.apiKey;
        console.info(exports.LOG_PREFIX + "::getOtherKnownDevices ", fivestars_pos_sdk_storage_1.PairingModel.knownDevices.filter(function (device) { return device.apiKey !== PAIRED_DEVCE_API_KEY; }));
        return Promise.resolve(fivestars_pos_sdk_storage_1.PairingModel.knownDevices.filter(function (device) { return device.apiKey !== PAIRED_DEVCE_API_KEY; }));
    };
    /**
    * Get KnownDevice representation of the paired device. If it is not found in the known devices, construct one with incomplete info
    */
    Pairing.prototype.getPairedKnownDevice = function () {
        console.info(exports.LOG_PREFIX + "::getPairedKnownDevice ");
        var pairedDevice = fivestars_pos_sdk_storage_1.PairingModel.pairedDevice;
        if (!pairedDevice) {
            return Promise.resolve(pairedDevice);
        }
        var PAIRED_DEVICE = fivestars_pos_sdk_storage_1.PairingModel.knownDevices.find(function (device) { return device.apiKey === pairedDevice.apiKey; });
        if (PAIRED_DEVICE) {
            return Promise.resolve(PAIRED_DEVICE);
        }
        // paired device does not yet exist in the list of known devices, but we know we're supposed to be paired
        // construct an instance of KnownDevice for pairing screen display
        return Promise.resolve({
            apiKey: pairedDevice.apiKey,
            apiSecret: pairedDevice.apiSecret,
            bluetoothMacAddress: pairedDevice.bluetoothMacAddress,
            color: customerDeviceColor_1.getCustomerDeviceColor(pairedDevice.deviceDescription),
            deviceDescription: pairedDevice.deviceDescription,
            hardwareId: null,
            lastUpdateReceived: null,
            pairedDevice: {
                apiKey: fivestars_pos_sdk_storage_1.AuthModel.loyaltyCredentials.apiKey,
                apiSecret: '',
                bluetoothMacAddress: '',
                deviceDescription: pairedDevice.deviceDescription || '',
                //                hardwareId: device.HARDWARE_ID, //AB todo: check if the next line is ok to substitute for this line
                //                hardwareId: PAIRED_DEVICE?.hardwareId ?? null,                
                hardwareId: '',
                udpPort: 0
            },
            udpPort: pairedDevice.udpPort
        });
    };
    return Pairing;
}());
exports.Pairing = Pairing;
