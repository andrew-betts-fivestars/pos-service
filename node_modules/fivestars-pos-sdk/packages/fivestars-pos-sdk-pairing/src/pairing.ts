import { cloneDeep } from 'lodash'
import { Core } from "@fivestars-pos-sdk/fivestars-pos-sdk-core"
import { AuthModel, PairingModel } from '@fivestars-pos-sdk/fivestars-pos-sdk-storage'
import { ILoyaltyCredentials, KnownDevice, MessageDetails, PairedDevice, SendOptions, WebSocketCommonAction } from '@fivestars-pos-sdk/types'
import { getCustomerDeviceColor } from './utils/customerDeviceColor'
import { SkewAdjustedTime } from './utils/skewAdjustedTime'
import WebSocket from 'isomorphic-ws'
import { getPackedApiKey } from './utils/packedApiKey'

export const LOG_PREFIX = 'Pairing';

export class Pairing {
    private core: Core

    constructor() {
        this.core = new Core()
        this.core.on('device_mapping', this.onDeviceMapping)
        this.core.on('cts_info', this.onDeviceInfoUpdate)
        this.core.on('WEB_SOCKET_AUTHENTICATION_SUCCESSFUL', this.sendSubscriberAuthenticated)
        // this.core.on('WEB_SOCKET_AUTHENTICATION_SUCCESSFUL', (event: WebSocket.MessageEvent) => {
        //     console.log('in pairing::WEB_SOCKET_AUTHENTICATION_SUCCESSFUL')
        // })
        
        console.info(`${LOG_PREFIX}::constructor`);
    }

    public start = (loyaltyCredentials: ILoyaltyCredentials): void => {
       console.info(`${LOG_PREFIX}::start`);
       this.core?.start(loyaltyCredentials)
    }

    public pair(pairedDevice: PairedDevice) : Promise<boolean> {
        console.info(`${LOG_PREFIX}::start`, pairedDevice)
        PairingModel.pairedDevice = pairedDevice
        this.core.setPairedDevice(pairedDevice)
        return Promise.resolve(true)
    }
    
    public unPair(notifyPairedDevice = true): Promise<boolean> {
        console.info(`${LOG_PREFIX}::start`, notifyPairedDevice)
        PairingModel.pairedDevice = null
        this.core.setPairedDevice(null)        
        return Promise.resolve(true)
    }

    public getInPairingMode() : Promise<boolean> {
        console.info(`${LOG_PREFIX}::getInPairingMode `, PairingModel.inPairingMode)        
        return Promise.resolve(PairingModel.inPairingMode)
    }

    public getPairedDevice(): PairedDevice | null {
        console.info(`${LOG_PREFIX}::getPairedDevice `, PairingModel.pairedDevice)
        return PairingModel.pairedDevice
    }

    public isPairingConfigured() : Promise<boolean> {
        console.info(`${LOG_PREFIX}::isPairingConfigured `, PairingModel.pairedDevice !== null)
        return Promise.resolve(PairingModel.pairedDevice !== null)        
    }

    public getDeviceDescription() : Promise<string | null> {
        console.info(`${LOG_PREFIX}::getDeviceDescription `, PairingModel.deviceDescription)        
        return Promise.resolve(PairingModel.deviceDescription)
    }

    //public getKnownDevices(): Promise<KnownDevice[]> {
    public getKnownDevices(): KnownDevice[] {        
        console.info(`${LOG_PREFIX}::getKnownDevices `, PairingModel.knownDevices)        
        return PairingModel.knownDevices
    }

    public setKnownDevices(knownDevices: KnownDevice[]): Promise<KnownDevice[]> {
        console.info(`${LOG_PREFIX}::setKnownDevices `, knownDevices)                
        PairingModel.knownDevices = knownDevices
        return Promise.resolve(PairingModel.knownDevices)        
    }

    /**
    * Get known devices -- minus the known device that corresponds to our paired apikey
    */
    public getOtherKnownDevices() : Promise<KnownDevice[]> {
        // AB todo: look to remove line below before PROD, fix any issue
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment     
        // @ts-ignore
        const PAIRED_DEVCE_API_KEY: string | null = PairingModel.pairedDevice.apiKey
        console.info(`${LOG_PREFIX}::getOtherKnownDevices `, PairingModel.knownDevices.filter(device => device.apiKey !== PAIRED_DEVCE_API_KEY))                
        return Promise.resolve(PairingModel.knownDevices.filter(device => device.apiKey !== PAIRED_DEVCE_API_KEY))
    }

    /**
    * Get KnownDevice representation of the paired device. If it is not found in the known devices, construct one with incomplete info
    */

    public getPairedKnownDevice(): Promise<KnownDevice> {
        console.info(`${LOG_PREFIX}::getPairedKnownDevice `)                
        const pairedDevice: any = PairingModel.pairedDevice
        if (!pairedDevice) {
            return Promise.resolve(pairedDevice)
        }

        const PAIRED_DEVICE: KnownDevice | undefined = PairingModel.knownDevices.find(
            device => device.apiKey === pairedDevice.apiKey
        );

        if (PAIRED_DEVICE) {
            return Promise.resolve(PAIRED_DEVICE)
        }

        // paired device does not yet exist in the list of known devices, but we know we're supposed to be paired
        // construct an instance of KnownDevice for pairing screen display

        return Promise.resolve({
            apiKey: pairedDevice.apiKey,
            apiSecret: pairedDevice.apiSecret,
            bluetoothMacAddress: pairedDevice.bluetoothMacAddress,
            color: getCustomerDeviceColor(pairedDevice.deviceDescription),
            deviceDescription: pairedDevice.deviceDescription,
            hardwareId: null,
            lastUpdateReceived: null,
            pairedDevice: {
                apiKey: AuthModel.loyaltyCredentials.apiKey,
                apiSecret: '',
                bluetoothMacAddress: '',
                deviceDescription: pairedDevice.deviceDescription || '',
//                hardwareId: device.HARDWARE_ID, //AB todo: check if the next line is ok to substitute for this line
//                hardwareId: PAIRED_DEVICE?.hardwareId ?? null,                
                hardwareId: '',
                udpPort: 0
            },
            udpPort: pairedDevice.udpPort
        })
    }

    private deletePairedDevice = (): void => {
        console.info(`${LOG_PREFIX}::deletePairedDevice `)                
        PairingModel.pairedDevice = null
    };

    /** 
        Function: processDeviceMapping

        Paramaters:    
            apiKey:
            apiSecret:
            bluetoothMacAddress:
            deviceDescription:
            hardwareId:
            udpPort:

        Description: called when @fivestars-pos-sdk-messenger receives 'ws.device_mapping' websocket message
    */
    public onDeviceMapping = (event: WebSocket.MessageEvent): void => {
        console.info(`${LOG_PREFIX}::onDeviceMapping received 'device_mapping'`, event)
        const message: any = JSON.parse(event.data as string);

        const PAIRED_DEVICE: PairedDevice | null = this.getPairedDevice()

        // Exit if not paired because there is nothing to update
        if (!PAIRED_DEVICE) {
            return
        }

        // If the hardware identifier is set then verify paired device using the hardware identifier
        if (
            PAIRED_DEVICE.hardwareId &&
            message.hardwareId &&
            PAIRED_DEVICE.hardwareId !== message.hardwareId
        ) {
            return
        }

        // If the hardware identifier is not set then use the device description to verify paired device
        if (
            (!PAIRED_DEVICE.hardwareId || !message.hardwareId) &&
            PAIRED_DEVICE.deviceDescription !== message.deviceDescription
        ) {
            return
        }

        /**
        * Check if something about our paired device
        * has changed which will affect communication.
        * Use pairing action to update the paired device in redux, and trigger reconnect for messenger transports
        */
        if (
            message.apiKey !== PAIRED_DEVICE.apiKey ||
            message.apiSecret !== PAIRED_DEVICE.apiSecret ||
            message.bluetoothMacAddress !== PAIRED_DEVICE.bluetoothMacAddress ||
            message.udpPort !== PAIRED_DEVICE.udpPort
        ) {
            this.pair({
                apiKey: message.apiKey,
                apiSecret: message.apiSecret,
                bluetoothMacAddress: message.bluetoothMacAddress,
                deviceDescription: PAIRED_DEVICE.deviceDescription,

                hardwareId: PAIRED_DEVICE.hardwareId,
                udpPort: message.udpPort
            })
        }
    }

    /**
        Function: processErroneousPairing

        Parameters:
            erroneousDeviceApiKey: string,
            pairedDeviceApiKey: string)

        Description:
        This is a special case action for clearing out an erroneous pairing relationship
        which doesn't have the side-effects of "unpair"
    */
    public onErroneousPairing = (event: WebSocket.MessageEvent): void => {
        console.info(`${LOG_PREFIX}::onErroneousPairing received 'erroneous_pairing'`, event)
        const message: any = JSON.parse(event.data as string);

        const LOYALTY_CREDENTIALS: ILoyaltyCredentials = <ILoyaltyCredentials>AuthModel.loyaltyCredentials
        const PAIRED_DEVICE: PairedDevice | null = this.getPairedDevice()

        // If this message was not for this device, or this device is not paired, or
        // it is not from our paired device then we ignore the message
        if (
            message.erroneousDeviceApiKey !== LOYALTY_CREDENTIALS.apiKey ||
            !PAIRED_DEVICE ||
            message.pairedDeviceApiKey !== PAIRED_DEVICE.apiKey
        ) {
            return
        }

//        console.warn(`${LOG_PREFIX}::processErroneousPairing`, `Clearing pairing to ${PAIRED_DEVICE.apiKey}`);
//        messengerActions.clearPairedMessageQueue() // AB todo: implement this queue, grab from instore
        const NOTIFY_PAIRED_DEVICE = false
        this.unPair(NOTIFY_PAIRED_DEVICE)
    };

    public onDeviceInfoUpdate = (event: any): void => {
        console.info(`${LOG_PREFIX}::onDeviceInfoUpdate received 'cts_info'`, event)
//        const message: any = JSON.parse(event);
//        console.info(`${LOG_PREFIX}::onDeviceInfoUpdate message after JSON.parse `, message)
        PairingModel.knownDevices.push({
            lastUpdateReceived: SkewAdjustedTime.moment(),
            apiKey: event.apikey,
            apiSecret: null,
            bluetoothMacAddress: null,
            udpPort: null,
            color: event.color,
            deviceDescription: event.description,
            pairedDevice: event.pairedDevice,
            hardwareId: event.pairedDeviceHardwareId
        })
        console.info(`${LOG_PREFIX}::onDeviceInfoUpdate PairingModel.knownDevices `, PairingModel.knownDevices)
    }

    sendPairedMessage = async (
        messageDetails: MessageDetails,
        options: SendOptions
    ): Promise<string | null> => {
        let UUID: string | null = await this.core.sendPaired(messageDetails, options)

        if (!UUID) {
            console.info(`${LOG_PREFIX}::sendPairedMessage`, `Failed to send message`);
            console.info(`${LOG_PREFIX}::sendPairedMessage`, messageDetails);
        }

        return UUID;
    };

    constructPairedMessageDetails = (
        messageData: any,
        messageType: string
    ): MessageDetails => {
        console.log('Pairing::constructPairedMessageDetails', messageData, messageType)
        console.log('Pairing::constructPairedMessageDetails this.getPairedDevice()', this.getPairedDevice())        
        const PAIRED_DEVICE: PairedDevice | null = this.getPairedDevice()
        return {
            destination: PAIRED_DEVICE ? getPackedApiKey(PAIRED_DEVICE.apiKey) : null,
            messageData,
            messageType,
            source: getPackedApiKey(AuthModel.loyaltyCredentials.apiKey),
//            webappVersion: CONFIG.VERSION.APP_VERSION
            webappVersion: "420"  // AB todo: use from config eventually
        };
    }

    public sendSubscriberAuthenticated = () => {
        console.log('Pairing::sendSubscriberAuthenticated')
        const MESSAGE_DATA: object = {};
        const MESSAGE_DETAILS: MessageDetails = this.constructPairedMessageDetails(
            MESSAGE_DATA,
            WebSocketCommonAction.SUBSCRIBER_AUTHENTICATED
        )

        console.log('Pairing::sendSubscriberAuthenticated MESSAGE_DETAILS: ', MESSAGE_DETAILS)

        if (MESSAGE_DETAILS.destination) {
            this.sendPairedMessage( MESSAGE_DETAILS, {
                skipAcknowledgment: true,
                uuid: null
            });
        }
    };

}