import * as _ from 'lodash';

import { CONFIG } from "@fivestars-pos-sdk/config"
// import { IDinero } from "@fivestars-pos-sdk/types"
//import { RoundingMode } from 'dinero.js';
import { Dinero, RoundingMode } from 'dinero.js';

console.log("CONFIG: ", JSON.stringify(CONFIG))

/* eslint-disable-next-line @typescript-eslint/no-var-requires */
const dineroJs = require('dinero.js');

export interface IMoney {
    _getDinero(): Dinero;
    getAmount(): number;
    add(addend: IMoney): IMoney;
    subtract(subtrahend: IMoney): IMoney;
    multiply(multiplier: number): IMoney;
    divide(divisor: number): IMoney;
    percentage(percent: number): IMoney;
    equals(comparator: IMoney): boolean;
    greaterThan(comparator: IMoney): boolean;
    lessThan(comparator: IMoney): boolean;
    toDisplayFormat(): string;
    roundedDown(): number;
    roundedUp(): number;
    cashOptions(): IMoney[];
}

const BILL_DENOMIATIONS: number[] = [100, 500, 1000, 2000, 5000, 10000];

export class Money implements IMoney {
    private dinero: Dinero;

//    static CURRENCY = CONFIG.DINERO.get().CURRENCY;
    static CURRENCY = 'USD'
//    static FORMAT = CONFIG.DINERO.get().FORMAT;
    static FORMAT = '\$0,0.00'
//    static FORMAT_ROUNDING_MODE = CONFIG.DINERO.get().FORMAT_ROUNDING_MODE;
    static FORMAT_ROUNDING_MODE = 'HALF_AWAY_FROM_ZERO'
//    static LOCALE = CONFIG.DINERO.get().LOCALE;
    static LOCALE = 'en-US'
//    static PRECISION = CONFIG.DINERO.get().PRECISION;
    static PRECISION = 2    
//    static ROUNDING_MODE = CONFIG.DINERO.get().ROUNDING_MODE;
    static ROUNDING_MODE = 'HALF_EVEN'

    constructor(amount: number | null, dinero?: Dinero) {
        if (
            !(
                Money.CURRENCY &&
                Money.FORMAT &&
                Money.FORMAT_ROUNDING_MODE &&
                Money.LOCALE &&
                Money.PRECISION &&
                Money.ROUNDING_MODE
            )
        ) {
            throw new Error(
                'Must specify currency, format, format rounding mode, locale, precision, and rounding mode in the configuration for Money objects'
            );
        }
        if (dinero) {
            this.dinero = dinero.multiply(1);
        } else if (amount || amount === 0) {
            this.dinero = dineroJs({
                amount,
                currency: Money.CURRENCY,
                precision: Money.PRECISION
            }).setLocale(Money.LOCALE);
        } else {
            throw new Error('Must specify either a dinero object or amount to create a new Money object');
        }
    }

    public _getDinero() {
        return this.dinero;
    }

    public getAmount() {
        return this.dinero.getAmount();
    }

    public add(addend: Money) {
        return new Money(null, this.dinero.add(addend.dinero));
    }

    public subtract(subtrahend: Money) {
        return new Money(null, this.dinero.subtract(subtrahend.dinero));
    }

    public multiply(multiplier: number) {
        return new Money(null, this.dinero.multiply(multiplier, Money.ROUNDING_MODE as RoundingMode));
    }

    public divide(divisor: number) {
        return new Money(null, this.dinero.divide(divisor, Money.ROUNDING_MODE as RoundingMode));
    }

    public percentage(percent: number) {
        return new Money(null, this.dinero.percentage(percent));
    }

    public equals(comparator: Money) {
        return this.dinero.equalsTo(comparator.dinero);
    }

    public lessThan(comparator: Money) {
        return this.dinero.lessThan(comparator.dinero);
    }

    public greaterThan(comparator: Money) {
        return this.dinero.greaterThan(comparator.dinero);
    }

    public toDisplayFormat() {
        return this.dinero.toFormat(Money.FORMAT, Money.FORMAT_ROUNDING_MODE as RoundingMode);
    }

    public roundedDown() {
        return this.dinero.toRoundedUnit(0, 'HALF_DOWN');
    }

    public roundedUp() {
        return this.dinero.toRoundedUnit(0, 'HALF_UP');
    }

    public cashOptions() {
        /*
            This function returns an arry on money objects that represents the next closest
            full dollar amount for the range of bill denominations $1-$100 as compared to the total.

            e.g.  a Money object with an amount 0f 350, would return the and array of money objects
            at values 400 (next closest $1), 500 (next closest 5$), etc.

            That array of objects will then get de-duped based on the amount.

            e.g. a Money object og 650 would have a next closest $5 and $10 of $10.  We use these options
            to populate cash submit options, so we only want each option to be reflected once.
        */
        // A Money amount of 0 would result in no bills being required to get there, so use 1 as a minimum
        const DINERO_AMOUNT: number = this.dinero.getAmount() || 1;

        const OPTIONS: IMoney[] = BILL_DENOMIATIONS.map((denomiation: number) => {
            const SUFFICIENT_BILLS: number = Math.ceil(DINERO_AMOUNT / denomiation);
            return new Money(SUFFICIENT_BILLS * denomiation);
        })
            // filter out an option that is equal to our original amount
            .filter((money: IMoney) => money.getAmount() !== DINERO_AMOUNT);
        return _.uniqBy(OPTIONS, (options: IMoney) => options.getAmount());
    }

    public toJSON(): string {
        return JSON.stringify(this.dinero.toObject());
    }
}
